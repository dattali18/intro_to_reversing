/* This file was generated by the Hex-Rays decompiler version 9.1.0.250226.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <math.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void __noreturn start(); // weak
// INT_PTR __userpurge DialogFunc@<eax>(HWND eax0@<eax>, int a1, int a2, int a3, int a4);
int __stdcall sub_4014D3(int a1, int a2, int a3, int a4);
// INT_PTR __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
// HWND __stdcall SetFocus(HWND hWnd);
// void __stdcall __noreturn ExitProcess(UINT uExitCode);
// HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);
// HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);
// HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);
// HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);
// HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);
// LPVOID __stdcall LockResource(HGLOBAL hResData);
// DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);
// void __stdcall InitCommonControls();
int sub_4015DC();
_DWORD __stdcall sub_401619(_DWORD); // weak
void __cdecl sub_4016B4(void *a1, const void *a2, unsigned int a3);
// __int64 __usercall sub_4016D2@<edx:eax>(double a1@<st0>);
long double __cdecl sub_4016DB(long double a1, long double a2);
void __cdecl sub_4016FC(void *a1, unsigned int a2, int a3);
int __cdecl sub_40173F(int a1, int a2, int a3);
char __cdecl sub_401790(signed int a1);
int sub_401887();
void __stdcall __noreturn StartAddress();
__int64 __cdecl sub_401AB1(int a1, int a2);
_DWORD *__cdecl sub_401AE6(int a1, int a2, int a3, int a4, int *a5);
char __cdecl sub_401B63(__int16 *hMem);
char __cdecl sub_401C36(DWORD ThreadId);
char __cdecl sub_401DD2(int a1);
char *__cdecl sub_401E62(int a1, int a2);
int __cdecl sub_4024BE(_WORD *a1, float *a2, int a3);
int __cdecl sub_402517(int a1);
int __cdecl sub_40255A(int a1);
int __cdecl sub_4025E8(int a1, _BYTE *a2);
// char __usercall sub_4026D3@<al>(unsigned int a1@<edx>, int a2);
char __cdecl sub_4027B5(int a1, int *a2, _DWORD *a3, char a4, int a5, int a6, unsigned __int8 a7, unsigned __int8 a8, unsigned __int8 a9, int *a10, int *a11, _BYTE *a12, int *a13, char a14);
int __cdecl sub_4028AE(int a1, unsigned __int8 a2);
int __cdecl sub_4029A4(int a1, int a2);
int __cdecl sub_402A84(int a1);
int __cdecl sub_402AC9(int a1, int a2, int a3);
int __cdecl sub_402CE2(int a1, int a2);
int __cdecl sub_402D63(int a1);
int __cdecl sub_403596(int a1);
int sub_403C1E(); // weak
int __cdecl sub_403CD6(int *a1, int a2);
// MMRESULT __stdcall waveOutClose(HWAVEOUT hwo);
// MMRESULT __stdcall waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);
// MMRESULT __stdcall waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);
// MMRESULT __stdcall waveOutPause(HWAVEOUT hwo);
// MMRESULT __stdcall waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
// MMRESULT __stdcall waveOutReset(HWAVEOUT hwo);
// MMRESULT __stdcall waveOutRestart(HWAVEOUT hwo);
// MMRESULT __stdcall waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
// MMRESULT __stdcall waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);
// BOOL __stdcall CloseHandle(HANDLE hObject);
// HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// void __stdcall __noreturn ExitThread(DWORD dwExitCode);
// DWORD __stdcall ResumeThread(HANDLE hThread);
// BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);
// void __stdcall Sleep(DWORD dwMilliseconds);
// DWORD __stdcall SuspendThread(HANDLE hThread);

//-------------------------------------------------------------------------
// Data declarations

CHAR TemplateName[] = "injectme"; // idb
float flt_40606C = 1.0; // weak
float flt_406070 = 1000.0; // weak
float flt_406074 = 0.001; // weak
float flt_406078 = 0.40000001; // weak
float flt_40607C = 255.0; // weak
float flt_406080 = 256.0; // weak
float flt_406084 = 0.0039215689; // weak
float flt_406088 = 0.00390625; // weak
float flt_40608C = 4.6566129e-10; // weak
double dbl_406094 = 256.0; // weak
double dbl_40609C = 0.049087375; // weak
double dbl_4060A4 = 64.0; // weak
float flt_4060AC = 0.024543688; // weak
double dbl_4060B4 = 13.375; // weak
double dbl_4060BC = 2.0; // weak
float flt_4060C4 = 0.083333336; // weak
double dbl_4060CC = 8363.0; // weak
float flt_4060D4 = 0.0013020834; // weak
float flt_4060D8 = 4608.0; // weak
float flt_4060DC = 7.4214768e-9; // weak
int dword_4060E0 = 1000; // weak
char byte_4060E4 = '\x01'; // weak
char byte_4060E5[] = { 'E' }; // weak
HINSTANCE hModule = NULL; // idb
int dword_406308; // weak
HGLOBAL hMem; // idb
int dword_406310; // weak
int dword_406314; // weak
int dword_406318; // weak
char byte_406320; // weak
char byte_406321; // weak
HANDLE hThread; // idb
int dword_406328; // weak
int dword_40632C; // weak
int dword_406330; // weak
int dword_406334; // weak
int dword_406338; // weak
int dword_40633C; // weak
int dword_406340; // weak
int dword_406344; // weak
int dword_406348; // weak
int dword_40634C; // weak
int dword_406350; // weak
int dword_406354; // weak
int dword_406358; // weak
int dword_40635C; // weak
float flt_406360; // weak
float flt_406364; // weak
int dword_406368; // weak
int dword_40636C; // weak
float flt_406370; // weak
float flt_406374; // weak
int dword_406378; // weak
int dword_40637C; // weak
int dword_406380; // weak
int dword_406384; // weak
float flt_406388; // weak
_UNKNOWN unk_406398; // weak
_UNKNOWN unk_40639C; // weak
_UNKNOWN unk_407918; // weak
HGLOBAL dword_407A6C; // idb
int dword_407A78; // weak
_UNKNOWN unk_407AB8; // weak
_UNKNOWN unk_407AEC; // weak
int dword_40D2B8; // weak
HGLOBAL pwh; // idb
int dword_40D2DC; // weak
int dword_40D2E0; // weak
int dword_40D2E4; // weak
int dword_40D2E8; // weak
int dword_40D2EC; // weak
int dword_40D2F8; // weak
int dword_40D2FC; // weak
int dword_40D300; // weak
int dword_40D304; // weak
HGLOBAL dword_40D308; // idb
HWAVEOUT hwo; // idb
float flt_40D310; // weak
int dword_40D314; // weak


//----- (00401000) --------------------------------------------------------
void __noreturn start()
{
  INT_PTR v0; // eax

  InitCommonControls();
  hModule = GetModuleHandleA(0);
  v0 = DialogBoxParamA(hModule, TemplateName, 0, (DLGPROC)DialogFunc, 0);
  ExitProcess(v0);
}
// 401000: using guessed type void __noreturn start();

//----- (00401030) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
INT_PTR __userpurge DialogFunc@<eax>(HWND eax0@<eax>, int a1, int a2, int a3, int a4)
{
  HGLOBAL Resource; // eax
  const void *v6; // esi
  _DWORD *v7; // eax
  unsigned int v8; // ecx
  HRSRC ResourceA; // [esp-14h] [ebp-14h]
  int v11; // [esp-Ch] [ebp-Ch]
  int v12; // [esp-8h] [ebp-8h]
  int v13; // [esp-4h] [ebp-4h]
  int savedregs; // [esp+0h] [ebp+0h]

  if ( a2 != 272 )
    JUMPOUT(0x4014D9);
  SetFocus(eax0);
  ResourceA = FindResourceA(hModule, (LPCSTR)0x1F4, (LPCSTR)0xA);
  dword_406308 = SizeofResource(hModule, ResourceA);
  Resource = LoadResource(hModule, ResourceA);
  v6 = LockResource(Resource);
  v7 = GlobalAlloc(0x40u, dword_406308 + 4);
  hMem = v7;
  v8 = dword_406308;
  *v7 = dword_406308;
  qmemcpy(v7 + 1, v6, v8);
  sub_401619(hMem);
  sub_4014D3(v11, v12, v13, savedregs);
  return sub_4014D3(a1, 272, a3, a4);
}
// 4010B5: positive sp value C has been found
// 40103A: control flows out of bounds to 4014D9
// 4010B0: variable 'v11' is possibly undefined
// 4010B0: variable 'v12' is possibly undefined
// 4010B0: variable 'v13' is possibly undefined
// 4010B0: variable 'savedregs' is possibly undefined
// 401619: using guessed type _DWORD __stdcall sub_401619(_DWORD);
// 406308: using guessed type int dword_406308;

//----- (004014D3) --------------------------------------------------------
// positive sp value has been detected, the output may be wrong!
int __stdcall sub_4014D3(int a1, int a2, int a3, int a4)
{
  return 1;
}
// 40158A: positive sp value 4 has been found

//----- (004015DC) --------------------------------------------------------
int sub_4015DC()
{
  HANDLE v1; // [esp-8h] [ebp-8h]
  int v2; // [esp-4h] [ebp-4h]

  dword_40D314 = ~dword_40D314;
  v2 = dword_40D314;
  v1 = hThread;
  if ( dword_40D314 )
  {
    SuspendThread(hThread);
    waveOutPause(hwo);
  }
  else
  {
    waveOutRestart(hwo);
    ResumeThread(v1);
  }
  return -v2;
}
// 40D314: using guessed type int dword_40D314;

//----- (00401619) --------------------------------------------------------
#error "40163A: call analysis failed (funcsize=36)"

//----- (004016B4) --------------------------------------------------------
void __cdecl sub_4016B4(void *a1, const void *a2, unsigned int a3)
{
  qmemcpy(a1, a2, a3);
}

//----- (004016D2) --------------------------------------------------------
__int64 __usercall sub_4016D2@<edx:eax>(double a1@<st0>)
{
  return (__int64)a1;
}

//----- (004016DB) --------------------------------------------------------
long double __cdecl sub_4016DB(long double a1, long double a2)
{
  long double v2; // st7

  v2 = __FYL2X__(a1, a2);
  _ST6 = v2;
  __asm { frndint }
  return __FSCALE__(__F2XM1__(-(_ST6 - v2)) + 1.0, _ST6);
}

//----- (004016FC) --------------------------------------------------------
void __cdecl sub_4016FC(void *a1, unsigned int a2, int a3)
{
  int v3; // edx
  unsigned int v4; // eax

  if ( a3 )
  {
    v3 = dword_406318;
    v4 = a2;
    if ( dword_406318 + a2 >= dword_406314 )
      v4 = dword_406314 - dword_406318;
    dword_406318 += v4;
    sub_4016B4(a1, (const void *)(dword_406310 + v3), v4);
  }
}
// 406310: using guessed type int dword_406310;
// 406314: using guessed type int dword_406314;
// 406318: using guessed type int dword_406318;

//----- (0040173F) --------------------------------------------------------
int __cdecl sub_40173F(int a1, int a2, int a3)
{
  int result; // eax

  result = a1;
  if ( a1 )
  {
    if ( a3 )
    {
      if ( a3 == 1 )
      {
        dword_406318 += a2;
      }
      else if ( a3 == 2 )
      {
        dword_406318 = a2 + dword_406314;
      }
    }
    else
    {
      dword_406318 = a2;
    }
    result = dword_406314;
    if ( dword_406318 > dword_406314 )
      dword_406318 = dword_406314;
  }
  return result;
}
// 406314: using guessed type int dword_406314;
// 406318: using guessed type int dword_406318;

//----- (00401790) --------------------------------------------------------
char __cdecl sub_401790(signed int a1)
{
  int v1; // edi
  int *v2; // eax
  WAVEFORMATEX pwfx; // [esp+4h] [ebp-1Ch] BYREF
  __int64 v5; // [esp+18h] [ebp-8h]

  dword_40D304 = a1;
  pwfx.nSamplesPerSec = a1;
  pwfx.nAvgBytesPerSec = 4 * a1;
  pwfx.wFormatTag = 1;
  pwfx.nChannels = 2;
  pwfx.wBitsPerSample = 16;
  pwfx.nBlockAlign = 4;
  pwfx.cbSize = 0;
  if ( waveOutOpen(&hwo, 0xFFFFFFFF, &pwfx, 0, 0, 0) )
    return 0;
  __asm { finit }
  flt_40D310 = flt_40606C / (double)a1;
  dword_40D2FC = (20 * dword_40D304 / 1000 + 3) & 0xFFFFFFFC;
  dword_40D300 = 2 * dword_40D2FC * (dword_4060E0 / 20);
  v5 = (unsigned int)((dword_40D304 << 7) / 44100);
  dword_406384 = (dword_40D304 << 7) / 44100;
  flt_406388 = flt_40606C / (double)v5;
  memset(&unk_407AB8, 0, 0x5800u);
  v1 = 0;
  v2 = (int *)&unk_407AEC;
  do
  {
    *(v2 - 13) = v1;
    *v2 = 1;
    v2 += 22;
    ++v1;
  }
  while ( (int)v2 < (int)&dword_40D2EC );
  return 1;
}
// 40606C: using guessed type float flt_40606C;
// 4060E0: using guessed type int dword_4060E0;
// 406384: using guessed type int dword_406384;
// 406388: using guessed type float flt_406388;
// 40D2EC: using guessed type int dword_40D2EC;
// 40D2FC: using guessed type int dword_40D2FC;
// 40D300: using guessed type int dword_40D300;
// 40D304: using guessed type int dword_40D304;
// 40D310: using guessed type float flt_40D310;

//----- (00401887) --------------------------------------------------------
int sub_401887()
{
  int v0; // esi
  int v1; // eax
  int v2; // ecx
  int v3; // ebx
  int v4; // edi
  int v5; // eax
  int v6; // edi
  int result; // eax
  int v8; // [esp+Ch] [ebp-14h]
  void *v9; // [esp+10h] [ebp-10h]
  int v10; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]
  int v12; // [esp+1Ch] [ebp-4h]

  v0 = dword_40D2FC * dword_406328;
  v8 = dword_40D300 / dword_40D2FC;
  v9 = (void *)(dword_40D2B8 + 8 * dword_40D2FC * dword_406328);
  memset(v9, 0, 8 * dword_40D2FC);
  v1 = dword_406330;
  v2 = dword_40D2FC;
  v12 = 0;
  v3 = *(_DWORD *)(dword_406330 + 8);
  for ( i = (int)v9; v12 < dword_40D2FC; v1 = dword_406330 )
  {
    if ( v3 )
    {
      v4 = v3;
      v10 = v3;
    }
    else
    {
      (*(void (__cdecl **)(int))(v1 + 348))(v1);
      v2 = dword_40D2FC;
      v4 = *(_DWORD *)(dword_406330 + 12);
      v10 = v4;
      v3 = v4;
    }
    if ( v12 + v4 > v2 )
    {
      v4 = v2 - v12;
      v10 = v2 - v12;
    }
    sub_401E62(i, v4);
    v12 += v4;
    v3 -= v4;
    v5 = i + 8 * v4;
    v6 = dword_406330;
    i = v5;
    *(_DWORD *)(v6 + 340) += sub_4016D2((double)v10 * flt_40D310 * flt_406070);
    v2 = dword_40D2FC;
  }
  *(_DWORD *)((char *)dword_407A6C + 6 * dword_406328 + 2) = *(_DWORD *)(v1 + 340);
  *((_BYTE *)dword_407A6C + 6 * dword_406328 + 1) = *(_BYTE *)(dword_406330 + 320);
  *((_BYTE *)dword_407A6C + 6 * dword_406328) = *(_BYTE *)(dword_406330 + 324);
  *(_DWORD *)(dword_406330 + 8) = v3;
  sub_4024BE((_WORD *)(dword_40D2F8 + 4 * v0), (float *)v9, dword_40D2FC & 0x3FFFFFFF);
  ++dword_406328;
  result = v8;
  if ( dword_406328 >= v8 )
    dword_406328 = 0;
  return result;
}
// 406070: using guessed type float flt_406070;
// 406328: using guessed type int dword_406328;
// 406330: using guessed type int dword_406330;
// 40D2B8: using guessed type int dword_40D2B8;
// 40D2F8: using guessed type int dword_40D2F8;
// 40D2FC: using guessed type int dword_40D2FC;
// 40D300: using guessed type int dword_40D300;
// 40D310: using guessed type float flt_40D310;

//----- (00401A01) --------------------------------------------------------
void __stdcall __noreturn StartAddress()
{
  int v0; // edi
  int v1; // esi
  mmtime_tag pmmt; // [esp+8h] [ebp-Ch] BYREF

  byte_4060E4 = 0;
  v0 = dword_40D300 / dword_40D2FC;
  while ( !byte_406320 )
  {
    pmmt.wType = 4;
    waveOutGetPosition(hwo, &pmmt, 0xCu);
    pmmt.u.ms >>= 2;
    v1 = (signed int)pmmt.u.ms % dword_40D300 / dword_40D2FC;
    while ( dword_406328 != v1 )
    {
      byte_406321 = 1;
      sub_401887();
      if ( ++dword_40632C >= v0 )
        dword_40632C = 0;
      byte_406321 = 0;
    }
    Sleep(5u);
  }
  byte_4060E4 = 1;
  ExitThread(0);
}
// 4060E4: using guessed type char byte_4060E4;
// 406320: using guessed type char byte_406320;
// 406321: using guessed type char byte_406321;
// 406328: using guessed type int dword_406328;
// 40632C: using guessed type int dword_40632C;
// 40D2FC: using guessed type int dword_40D2FC;
// 40D300: using guessed type int dword_40D300;

//----- (00401AB1) --------------------------------------------------------
__int64 __cdecl sub_401AB1(int a1, int a2)
{
  double v2; // st7
  __int64 result; // rax

  v2 = (double)a2 * flt_406078;
  *(_DWORD *)(a1 + 316) = a2;
  result = sub_4016D2(flt_406070 / v2 * (double)dword_40D304 * flt_406074);
  *(_DWORD *)(a1 + 12) = result;
  return result;
}
// 406070: using guessed type float flt_406070;
// 406074: using guessed type float flt_406074;
// 406078: using guessed type float flt_406078;
// 40D304: using guessed type int dword_40D304;

//----- (00401AE6) --------------------------------------------------------
_DWORD *__cdecl sub_401AE6(int a1, int a2, int a3, int a4, int *a5)
{
  int *v5; // esi
  _DWORD *result; // eax
  _DWORD *v7; // edi
  int v8; // eax
  int v9; // eax
  int v10; // edi
  void *v11; // [esp-4h] [ebp-Ch]

  v5 = (int *)GlobalAlloc(0x40u, 0x164u);
  result = GlobalAlloc(0x40u, 0x18u);
  if ( result )
  {
    v7 = result;
    v8 = *a5;
    dword_406314 = v8;
    dword_406310 = (int)(a5 + 1);
    dword_406318 = 0;
    v7[4] = v8;
    if ( v8 )
    {
      v5[88] = a2;
      v9 = sub_403CD6(v5, (int)v7);
      v11 = v7;
      v10 = v9;
      GlobalFree(v11);
      result = v5;
      if ( v10 )
        return result;
      sub_401B63((__int16 *)v5);
    }
    else
    {
      GlobalFree(v7);
    }
    return 0;
  }
  return result;
}
// 406310: using guessed type int dword_406310;
// 406314: using guessed type int dword_406314;
// 406318: using guessed type int dword_406318;

//----- (00401B63) --------------------------------------------------------
char __cdecl sub_401B63(__int16 *hMem)
{
  int v2; // edi
  _DWORD *v4; // edi
  HGLOBAL *v5; // ebx
  int v6; // [esp+8h] [ebp-Ch]
  int v7; // [esp+Ch] [ebp-8h]
  int v8; // [esp+10h] [ebp-4h]
  HGLOBAL **hMema; // [esp+1Ch] [ebp+8h]

  v2 = 0;
  if ( !hMem )
    return 0;
  while ( byte_406321 )
    ;
  sub_401DD2((int)hMem);
  if ( *((_DWORD *)hMem + 1) )
  {
    v6 = 0;
    if ( hMem[16] > 0 )
    {
      v7 = 0;
      do
      {
        v8 = 0;
        v4 = (_DWORD *)(*((_DWORD *)hMem + 1) + v7);
        if ( (int)*v4 > 0 )
        {
          hMema = (HGLOBAL **)(v4 + 1);
          do
          {
            v5 = *hMema;
            if ( *hMema )
            {
              if ( *v5 )
                GlobalFree(*v5);
              GlobalFree(v5);
            }
            ++v8;
            ++hMema;
          }
          while ( v8 < *v4 );
        }
        ++v6;
        v7 += 340;
      }
      while ( v6 < hMem[16] );
      v2 = 0;
    }
  }
  if ( *((_DWORD *)hMem + 1) )
    GlobalFree(*((HGLOBAL *)hMem + 1));
  if ( *(_DWORD *)hMem )
  {
    if ( *((int *)hMem + 7) > 0 )
    {
      do
      {
        if ( *(_DWORD *)(*(_DWORD *)hMem + 8 * v2 + 4) )
          GlobalFree(*(HGLOBAL *)(*(_DWORD *)hMem + 8 * v2 + 4));
        ++v2;
      }
      while ( v2 < *((_DWORD *)hMem + 7) );
    }
    if ( *(_DWORD *)hMem )
      GlobalFree(*(HGLOBAL *)hMem);
  }
  GlobalFree(hMem);
  return 1;
}
// 406321: using guessed type char byte_406321;

//----- (00401C36) --------------------------------------------------------
char __cdecl sub_401C36(DWORD ThreadId)
{
  int v1; // esi
  int v2; // edi
  int v4; // eax
  void (__cdecl *v5)(int); // eax
  int v6; // edx
  _DWORD *v7; // ecx
  char *v8; // eax
  int v9; // edi
  HGLOBAL v10; // eax
  char *v11; // eax

  v1 = ThreadId;
  v2 = dword_40D300 / dword_40D2FC;
  if ( !ThreadId )
    return 0;
  v4 = *(unsigned __int8 *)(ThreadId + 296);
  *(_DWORD *)(ThreadId + 336) = -1;
  *(_DWORD *)(v1 + 332) = -1;
  *(_DWORD *)(v1 + 300) = v4;
  *(_DWORD *)(v1 + 312) = *(__int16 *)(v1 + 36);
  v5 = *(void (__cdecl **)(int))(v1 + 344);
  *(_DWORD *)(v1 + 320) = 0;
  *(_DWORD *)(v1 + 324) = 0;
  *(_DWORD *)(v1 + 8) = 0;
  *(_DWORD *)(v1 + 308) = 0;
  *(_DWORD *)(v1 + 328) = 0;
  *(_DWORD *)(v1 + 340) = 0;
  if ( v5 )
    v5(v1);
  sub_401AB1(v1, *(__int16 *)(v1 + 38));
  memset(&unk_406398, 0, 172 * *(__int16 *)(v1 + 20));
  v6 = 0;
  if ( *(__int16 *)(v1 + 20) > 0 )
  {
    v7 = &unk_40639C;
    v8 = (char *)&unk_407AB8;
    do
    {
      *v7 = v8;
      ++v6;
      v8 += 88;
      v7 += 43;
    }
    while ( v6 < *(__int16 *)(v1 + 20) );
  }
  dword_406330 = v1;
  dword_407A6C = GlobalAlloc(0x40u, 6 * v2);
  v9 = 4 * dword_40D300;
  v10 = GlobalAlloc(0x40u, 4 * dword_40D300);
  dword_40D2EC = -1;
  dword_40D2DC = v9;
  dword_40D2F8 = (int)v10;
  dword_40D2E8 = 12;
  pwh = v10;
  dword_40D2E0 = 0;
  dword_40D2E4 = 0;
  waveOutPrepareHeader(hwo, (LPWAVEHDR)&pwh, 0x20u);
  dword_40D308 = GlobalAlloc(0x40u, 8 * dword_40D300 + 256);
  v11 = (char *)dword_40D308 + 15;
  LOBYTE(v11) = ((_BYTE)dword_40D308 + 15) & 0xF0;
  dword_40D2B8 = (int)v11;
  dword_406328 = 0;
  do
    sub_401887();
  while ( dword_406328 );
  waveOutWrite(hwo, (LPWAVEHDR)&pwh, 0x20u);
  byte_406320 = 0;
  hThread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, 0, 2u, &ThreadId);
  SetThreadPriority(hThread, 15);
  return 1;
}
// 406320: using guessed type char byte_406320;
// 406328: using guessed type int dword_406328;
// 406330: using guessed type int dword_406330;
// 40D2B8: using guessed type int dword_40D2B8;
// 40D2DC: using guessed type int dword_40D2DC;
// 40D2E0: using guessed type int dword_40D2E0;
// 40D2E4: using guessed type int dword_40D2E4;
// 40D2E8: using guessed type int dword_40D2E8;
// 40D2EC: using guessed type int dword_40D2EC;
// 40D2F8: using guessed type int dword_40D2F8;
// 40D2FC: using guessed type int dword_40D2FC;
// 40D300: using guessed type int dword_40D300;

//----- (00401DD2) --------------------------------------------------------
char __cdecl sub_401DD2(int a1)
{
  if ( !a1 )
    return 0;
  byte_406320 = 1;
  while ( byte_406321 )
    ;
  if ( hThread )
  {
    while ( !byte_4060E4 )
      Sleep(0x32u);
    CloseHandle(hThread);
    hThread = 0;
  }
  if ( dword_40D308 )
    GlobalFree(dword_40D308);
  if ( pwh )
  {
    waveOutUnprepareHeader(hwo, (LPWAVEHDR)&pwh, 0x20u);
    dword_40D2E8 &= ~2u;
  }
  dword_406330 = 0;
  if ( dword_407A6C )
    GlobalFree(dword_407A6C);
  return 1;
}
// 4060E4: using guessed type char byte_4060E4;
// 406320: using guessed type char byte_406320;
// 406321: using guessed type char byte_406321;
// 406330: using guessed type int dword_406330;
// 40D2E8: using guessed type int dword_40D2E8;

//----- (00401E62) --------------------------------------------------------
char *__cdecl sub_401E62(int a1, int a2)
{
  int *v2; // ebp
  char *result; // eax
  int v4; // ecx
  int *v5; // ebx
  int v6; // esi
  unsigned __int64 v7; // rax
  __int64 v8; // rax
  int v9; // ebp
  unsigned int v10; // eax
  unsigned __int64 v11; // rt2
  _DWORD *v12; // ecx
  int v13; // eax
  int v14; // edx
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  unsigned int v19; // eax
  int v20; // ebx
  unsigned int v21; // ecx
  unsigned int v22; // ebp
  int v23; // edi
  unsigned int v24; // esi
  int v25; // edx
  unsigned int v26; // edx
  double v27; // st7
  double v28; // st6
  double v29; // st5
  unsigned int v30; // esi
  unsigned int v31; // kr10_4
  double v32; // st4
  double v33; // st2
  double v34; // st7
  double v35; // st7
  double v36; // st5
  double i; // st6
  double v38; // st4
  double v39; // st3
  double v40; // st2
  unsigned int v41; // esi
  unsigned int v42; // kr20_4
  double v43; // st1
  double v44; // rtt
  double v45; // st0
  double v46; // rt1
  double v47; // st2
  double v48; // st6
  double v49; // st4
  double v50; // st5
  double v51; // rt1
  double v52; // st4
  double v53; // st6
  double v54; // st5
  double v55; // st7
  double v56; // rt0
  double v57; // st5
  double v58; // st6
  double v59; // st5
  double v60; // st7
  double v61; // st6
  double v62; // st5
  double v63; // st4
  double v64; // st3
  double v65; // st2
  double v66; // st1
  double v67; // st3
  double v68; // rt1
  double v69; // st2
  double v70; // st5
  double v71; // st4
  int v72; // esi
  int v73; // edx
  char v74; // dl
  int v75; // ecx
  int *v76; // [esp-4h] [ebp-10h]
  int savedregs; // [esp+Ch] [ebp+0h] BYREF

  v2 = &savedregs;
  result = (char *)a2;
  if ( a2 > 0 )
  {
    dword_406338 = 0;
    dword_40633C = a2;
    dword_406340 = a1;
    dword_406344 = a1 + 8 * a2;
LABEL_3:
    result = (char *)&unk_407AB8 + 88 * dword_406338;
    dword_406334 = (int)result;
    v76 = v2;
    dword_406348 = dword_406340;
    v4 = (int)result;
    dword_406354 = (int)result;
    if ( !result )
      goto LABEL_55;
    v5 = (int *)*((_DWORD *)result + 7);
    dword_406350 = (int)v5;
    if ( !v5 )
      goto LABEL_55;
    dword_40635C = *v5;
    result = (char *)dword_40633C;
    while ( 1 )
    {
      while ( 1 )
      {
        do
        {
          dword_406358 = (int)result;
          v6 = *(_DWORD *)(v4 + 40);
          dword_40634C = 0;
          if ( *(_DWORD *)(v4 + 56) == 1 )
          {
            v7 = __PAIR64__(v5[3] + v5[2] - v6, 0) - *(unsigned int *)(v4 + 44);
          }
          else
          {
            HIDWORD(v8) = *(_DWORD *)(v4 + 40);
            LODWORD(v8) = *(_DWORD *)(v4 + 44);
            v7 = v8 - __PAIR64__(v5[2], 0);
          }
          if ( HIDWORD(v7) < 0x1000000 )
          {
            v9 = (*(_DWORD *)(v4 + 48) >> 8) & 0xFFFFFF | (*(_DWORD *)(v4 + 52) << 24);
            v11 = (v7 >> 8) % (unsigned int)v9;
            v10 = (v7 >> 8) / (unsigned int)v9;
            if ( (_DWORD)v11 )
              ++v10;
            if ( v10 <= dword_406358 )
            {
              dword_406358 = v10;
              dword_40634C = 1;
            }
          }
          v12 = (_DWORD *)dword_406354;
          dword_40637C = 0;
          dword_406380 = 0;
          dword_40636C = dword_406358;
          dword_406378 = 0;
          if ( *(_DWORD *)(dword_406354 + 84)
            && *(_DWORD *)(dword_406354 + 32) == *(_DWORD *)(dword_406354 + 60)
            && *(_DWORD *)(dword_406354 + 36) == *(_DWORD *)(dword_406354 + 64) )
          {
            dword_406378 = *(_DWORD *)(dword_406354 + 84);
            dword_40637C = *(_DWORD *)(dword_406354 + 76);
            dword_406380 = *(_DWORD *)(dword_406354 + 80);
          }
          else
          {
            v13 = *(_DWORD *)(dword_406354 + 32);
            v14 = *(_DWORD *)(dword_406354 + 68) >> 8;
            *(_DWORD *)(dword_406354 + 60) = v13;
            v15 = v13 - v14;
            if ( v15 )
            {
              dword_406368 = v15;
              *(float *)&dword_40637C = (double)v15 * flt_406084 * flt_406388;
              v12[19] = dword_40637C;
              dword_406378 = dword_406384;
            }
            v16 = v12[9];
            v17 = v12[18] >> 8;
            v12[16] = v16;
            v18 = v16 - v17;
            if ( v18 )
            {
              dword_406368 = v18;
              *(float *)&dword_406380 = (double)v18 * flt_406084 * flt_406388;
              v12[20] = dword_406380;
              dword_406378 = dword_406384;
            }
          }
          v19 = dword_406378;
          if ( dword_406378 > 0 )
          {
            v12[21] = dword_406378;
            if ( dword_406358 > v19 )
              dword_406358 = v19;
          }
          dword_406368 = *(_DWORD *)(dword_406354 + 36);
          flt_406364 = (double)dword_406368 * flt_406084;
          dword_406368 = *(_DWORD *)(dword_406354 + 32);
          flt_406360 = (double)dword_406368 * flt_406084;
          dword_406368 = *(_DWORD *)(dword_406354 + 72);
          flt_406374 = (double)dword_406368 * flt_406088 * flt_406084;
          dword_406368 = *(_DWORD *)(dword_406354 + 68);
          flt_406370 = (double)dword_406368 * flt_406088 * flt_406084;
          v20 = *(_DWORD *)(dword_406354 + 48);
          v21 = *(_DWORD *)(dword_406354 + 52);
          v22 = *(_DWORD *)(dword_406354 + 44);
          v23 = dword_406348;
          if ( *(_DWORD *)(dword_406354 + 56) != 1 )
          {
            v21 = (__PAIR64__(~v21, ~v20) + 1) >> 32;
            v20 = -v20;
          }
          v24 = ((unsigned int)dword_40635C >> 1) + *(_DWORD *)(dword_406354 + 40);
          v25 = dword_406358;
          if ( !dword_406378 )
          {
            v26 = (unsigned int)dword_406358 >> 1;
            if ( (unsigned int)dword_406358 >> 1 )
            {
              v23 = dword_406348 + 16;
              v27 = (double)*(__int16 *)(2 * v24 + 2);
              dword_406368 = v22 >> 1;
              v28 = (double)*(__int16 *)(2 * v24);
              v29 = (double)(v22 >> 1);
              v31 = v20 + 2 * (v22 >> 1);
              v30 = (__PAIR64__(v21, v20) + __PAIR64__(v24, 2 * (v22 >> 1))) >> 32;
              v32 = (double)*(__int16 *)(2 * v30 + 2);
              dword_406368 = v31 >> 1;
              v33 = v27;
              v34 = (double)*(__int16 *)(2 * v30);
              v24 = (__PAIR64__(v21, v20) + __PAIR64__(v30, 2 * (v31 >> 1))) >> 32;
              v22 = v20 + 2 * (v31 >> 1);
              v35 = v34 + (double)(v31 >> 1) * flt_40608C * (v32 - v34);
              v36 = v28 + v29 * flt_40608C * (v33 - v28);
              for ( i = v36 * flt_406360; ; i = v51 )
              {
                v52 = i;
                v53 = v35 * flt_406364;
                v54 = v36 * flt_406364 + *(float *)(v23 - 12);
                v55 = v35 * flt_406360 + *(float *)(v23 - 8);
                *(float *)(v23 - 16) = v52 + *(float *)(v23 - 16);
                v56 = v54;
                v57 = v53;
                v58 = v56;
                v59 = v57 + *(float *)(v23 - 4);
                if ( !--v26 )
                  break;
                dword_406368 = v22 >> 1;
                v38 = (double)*(__int16 *)(2 * v24 + 2);
                v39 = (double)*(__int16 *)(2 * v24);
                v40 = (double)(v22 >> 1);
                v42 = v20 + 2 * (v22 >> 1);
                v41 = (__PAIR64__(v21, v20) + __PAIR64__(v24, 2 * (v22 >> 1))) >> 32;
                v23 += 16;
                dword_406368 = v42 >> 1;
                v43 = (double)*(__int16 *)(2 * v41);
                v44 = (double)(v42 >> 1) * flt_40608C;
                v45 = (double)*(__int16 *)(2 * v41 + 2) - v43;
                v24 = (__PAIR64__(v21, v20) + __PAIR64__(v41, 2 * (v42 >> 1))) >> 32;
                v22 = v20 + 2 * (v42 >> 1);
                v46 = v40 * flt_40608C * (v38 - v39) + v39;
                v47 = v58;
                v48 = v46;
                *(float *)(v23 - 28) = v47;
                *(float *)(v23 - 24) = v55;
                v35 = v43 + v44 * v45;
                v49 = v59;
                v50 = v46 * flt_406360;
                *(float *)(v23 - 20) = v49;
                v51 = v50;
                v36 = v48;
              }
              *(float *)(v23 - 12) = v58;
              *(float *)(v23 - 8) = v55;
              *(float *)(v23 - 4) = v59;
            }
            v25 = dword_406358 & 1;
          }
          if ( v25 )
          {
            v60 = *(float *)&dword_40637C;
            v61 = *(float *)&dword_406380;
            v62 = flt_406370;
            v63 = flt_406374;
            do
            {
              v23 += 8;
              v64 = (double)*(__int16 *)(2 * v24 + 2);
              dword_406368 = v22 >> 1;
              v65 = (double)*(__int16 *)(2 * v24);
              v66 = (double)(v22 >> 1);
              v24 = (__PAIR64__(v21, v20) + __PAIR64__(v24, 2 * (v22 >> 1))) >> 32;
              v22 = v20 + 2 * (v22 >> 1);
              v67 = v66 * flt_40608C * (v64 - v65) + v65;
              v68 = v62 + v60;
              v69 = v67 * v62;
              v70 = v63 + v61;
              v71 = v67 * v63 + *(float *)(v23 - 4);
              *(float *)(v23 - 8) = v69 + *(float *)(v23 - 8);
              *(float *)(v23 - 4) = v71;
              v63 = v70;
              v62 = v68;
              --v25;
            }
            while ( v25 );
            *(float *)&dword_406380 = v61;
            *(float *)&dword_40637C = v60;
            LODWORD(flt_406370) = (int)(v62 * flt_40607C * flt_406080);
            LODWORD(flt_406374) = (int)(v63 * flt_40607C * flt_406080);
          }
          result = (char *)((unsigned int)dword_40635C >> 1);
          v72 = v24 - ((unsigned int)dword_40635C >> 1);
          if ( !dword_406378 )
            break;
          v5 = (int *)dword_406350;
          v4 = dword_406354;
          *(float *)(dword_406354 + 68) = flt_406370;
          *(float *)(v4 + 72) = flt_406374;
          result = (char *)dword_406358;
          v73 = dword_406378 - dword_406358;
          dword_40637C = 0;
          dword_406380 = 0;
          dword_406378 = v73;
          *(_DWORD *)(v4 + 84) = v73;
          if ( v73 )
            break;
          *(_DWORD *)(v4 + 76) = 0;
          *(_DWORD *)(v4 + 80) = 0;
          *(_DWORD *)(v4 + 68) = *(_DWORD *)(v4 + 32) << 8;
          *(_DWORD *)(v4 + 72) = *(_DWORD *)(v4 + 36) << 8;
          if ( (char *)dword_40636C == result )
            break;
          *(_DWORD *)(v4 + 40) = v72;
          *(_DWORD *)(v4 + 44) = v22;
          result = (char *)((unsigned int)(dword_406344 - v23) >> 3);
          dword_406348 = v23;
        }
        while ( result );
        if ( !dword_40634C )
          goto LABEL_54;
        v5 = (int *)dword_406350;
        v4 = dword_406354;
        v74 = *(_BYTE *)(dword_406350 + 29);
        if ( (v74 & 2) == 0 )
          break;
        do
          v72 -= *(_DWORD *)(dword_406350 + 12);
        while ( v72 >= (unsigned int)(*(_DWORD *)(dword_406350 + 12) + *(_DWORD *)(dword_406350 + 8)) );
        *(_DWORD *)(dword_406354 + 40) = v72;
        *(_DWORD *)(v4 + 44) = v22;
        result = (char *)((unsigned int)(dword_406344 - v23) >> 3);
        dword_406348 = v23;
        if ( !result )
          goto LABEL_54;
      }
      if ( (v74 & 4) == 0 )
      {
        v22 = 0;
        v72 = 0;
        *(_DWORD *)(dword_406354 + 28) = 0;
LABEL_54:
        v75 = dword_406354;
        *(_DWORD *)(dword_406354 + 44) = v22;
        *(_DWORD *)(v75 + 40) = v72;
LABEL_55:
        v2 = v76;
        if ( ++dword_406338 >= 64 )
          return result;
        goto LABEL_3;
      }
      if ( *(_DWORD *)(dword_406354 + 56) == 1 )
        goto LABEL_50;
      do
      {
        v72 = (__PAIR64__(v5[2], 0) + __PAIR64__(v5[2] - 1, -1) - __PAIR64__(v72, v22)) >> 32;
        v22 = -1 - v22;
        *(_DWORD *)(v4 + 56) = 1;
        if ( v72 < v5[3] + v5[2] )
          break;
LABEL_50:
        v72 = (__PAIR64__(v5[3] + v5[2] - 1, -1) + __PAIR64__(v5[3] + v5[2], 0) - __PAIR64__(v72, v22)) >> 32;
        v22 = -v22 - 1;
        *(_DWORD *)(v4 + 56) = 2;
      }
      while ( v72 < v5[2] );
      *(_DWORD *)(v4 + 40) = v72;
      *(_DWORD *)(v4 + 44) = v22;
      result = (char *)((unsigned int)(dword_406344 - v23) >> 3);
      dword_406348 = v23;
      if ( !result )
        goto LABEL_54;
    }
  }
  return result;
}
// 40607C: using guessed type float flt_40607C;
// 406080: using guessed type float flt_406080;
// 406084: using guessed type float flt_406084;
// 406088: using guessed type float flt_406088;
// 40608C: using guessed type float flt_40608C;
// 406334: using guessed type int dword_406334;
// 406338: using guessed type int dword_406338;
// 40633C: using guessed type int dword_40633C;
// 406340: using guessed type int dword_406340;
// 406344: using guessed type int dword_406344;
// 406348: using guessed type int dword_406348;
// 40634C: using guessed type int dword_40634C;
// 406350: using guessed type int dword_406350;
// 406354: using guessed type int dword_406354;
// 406358: using guessed type int dword_406358;
// 40635C: using guessed type int dword_40635C;
// 406360: using guessed type float flt_406360;
// 406364: using guessed type float flt_406364;
// 406368: using guessed type int dword_406368;
// 40636C: using guessed type int dword_40636C;
// 406370: using guessed type float flt_406370;
// 406374: using guessed type float flt_406374;
// 406378: using guessed type int dword_406378;
// 40637C: using guessed type int dword_40637C;
// 406380: using guessed type int dword_406380;
// 406384: using guessed type int dword_406384;
// 406388: using guessed type float flt_406388;

//----- (004024BE) --------------------------------------------------------
int __cdecl sub_4024BE(_WORD *a1, float *a2, int a3)
{
  int result; // eax
  int v5; // edi
  double v6; // st7
  float *v7; // [esp+Ch] [ebp+8h]

  result = (int)a2;
  v7 = a2;
  if ( a3 > 0 )
  {
    if ( a1 )
    {
      if ( a2 )
      {
        result = 2 * a3;
        if ( 2 * a3 > 0 )
        {
          v5 = 2 * a3;
          do
          {
            v6 = *v7++;
            result = (int)v6;
            if ( (int)v6 >= -32768 )
            {
              if ( result > 0x7FFF )
                result = 0x7FFF;
            }
            else
            {
              result = -32768;
            }
            *a1++ = result;
            --v5;
          }
          while ( v5 );
        }
      }
    }
  }
  return result;
}

//----- (00402517) --------------------------------------------------------
int __cdecl sub_402517(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // ecx
  int v4; // edx
  int v5; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 12);
  v3 = *(_DWORD *)(a1 + 128);
  if ( v2 >= v3 )
  {
    if ( v2 > v3 )
    {
      v5 = v2 - 4 * *(unsigned __int8 *)(a1 + 132);
      *(_DWORD *)(a1 + 12) = v5;
      if ( v5 < v3 )
        goto LABEL_6;
    }
  }
  else
  {
    v4 = v2 + 4 * *(unsigned __int8 *)(a1 + 132);
    *(_DWORD *)(a1 + 12) = v4;
    if ( v4 > v3 )
LABEL_6:
      *(_DWORD *)(a1 + 12) = v3;
  }
  *(_BYTE *)(a1 + 2) |= 1u;
  return result;
}

//----- (0040255A) --------------------------------------------------------
int __cdecl sub_40255A(int a1)
{
  int result; // eax
  unsigned int v2; // ecx

  if ( (*(_BYTE *)(a1 + 162) & 3) != 0 )
  {
    if ( (*(_BYTE *)(a1 + 162) & 3) == 1 )
    {
      LOBYTE(result) = 8 * *(_BYTE *)(a1 + 133);
      if ( *(char *)(a1 + 133) < 0 )
        LOBYTE(result) = -1 - result;
      result = (unsigned __int8)result;
    }
    else if ( (*(_BYTE *)(a1 + 162) & 3u) <= 1 || (*(_BYTE *)(a1 + 162) & 3u) > 3 )
    {
      result = a1;
    }
    else
    {
      result = 255;
    }
  }
  else
  {
    result = sub_4016D2(fabs(sin(((double)*(char *)(a1 + 133) + (double)*(char *)(a1 + 133)) * dbl_40609C) * dbl_406094));
  }
  v2 = ((result * *(unsigned __int8 *)(a1 + 135)) >> 5) & 0xFFFFFFFC;
  if ( *(char *)(a1 + 133) >= 0 )
    v2 = -v2;
  *(_BYTE *)(a1 + 2) |= 1u;
  *(_DWORD *)(a1 + 28) = v2;
  return result;
}
// 406094: using guessed type double dbl_406094;
// 40609C: using guessed type double dbl_40609C;

//----- (004025E8) --------------------------------------------------------
int __cdecl sub_4025E8(int a1, _BYTE *a2)
{
  int v2; // eax
  unsigned __int8 v3; // dl
  int v4; // ecx
  int v5; // eax
  int result; // eax

  if ( a2[334] )
  {
    switch ( a2[334] )
    {
      case 1:
        v2 = *(_DWORD *)(a1 + 92) >= 128 ? -64 : 64;
        break;
      case 2:
        v2 = (128 - (*(_DWORD *)(a1 + 92) + 128) % 256) >> 1;
        break;
      case 3:
        v2 = (128 - (384 - *(_DWORD *)(a1 + 92)) % 256) >> 1;
        break;
      default:
        v2 = (int)a2;
        break;
    }
  }
  else
  {
    v2 = sub_4016D2(sin((double)*(int *)(a1 + 92) * flt_4060AC) * dbl_4060A4);
  }
  v3 = a2[335];
  v4 = v2 * (unsigned __int8)a2[336];
  if ( v3 )
    v4 = v4 * *(_DWORD *)(a1 + 96) / v3;
  *(_DWORD *)(a1 + 28) += v4 >> 6;
  ++*(_DWORD *)(a1 + 96);
  v5 = (unsigned __int8)a2[335];
  if ( *(_DWORD *)(a1 + 96) > v5 )
    *(_DWORD *)(a1 + 96) = v5;
  *(_DWORD *)(a1 + 92) += (unsigned __int8)a2[337];
  result = *(_DWORD *)(a1 + 92);
  if ( result > 255 )
  {
    result -= 256;
    *(_DWORD *)(a1 + 92) = result;
  }
  *(_BYTE *)(a1 + 2) |= 1u;
  return result;
}
// 4060A4: using guessed type double dbl_4060A4;
// 4060AC: using guessed type float flt_4060AC;

//----- (004026D3) --------------------------------------------------------
char __usercall sub_4026D3@<al>(unsigned int a1@<edx>, int a2)
{
  int v2; // edx
  int v3; // edx
  int v4; // edx
  double v5; // st7
  int v6; // eax
  char v7; // dl
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  char result; // al

  LOBYTE(a1) = *(_BYTE *)(a2 + 162);
  v2 = (a1 >> 4) & 3;
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( !v3 )
    {
      LOBYTE(v6) = 8 * (*(_BYTE *)(a2 + 137) & 0x1F);
      if ( *(char *)(a2 + 137) < 0 )
        LOBYTE(v6) = -1 - v6;
      v6 = (unsigned __int8)v6;
      goto LABEL_12;
    }
    v4 = v3 - 1;
    if ( !v4 )
    {
      *(_DWORD *)(a2 + 24) = 255;
      goto LABEL_13;
    }
    if ( v4 != 1 )
      goto LABEL_13;
    v5 = (double)*(char *)(a2 + 133);
  }
  else
  {
    v5 = (double)*(char *)(a2 + 133);
  }
  v6 = sub_4016D2(fabs(sin((v5 + v5) * dbl_40609C) * dbl_406094));
LABEL_12:
  *(_DWORD *)(a2 + 24) = v6;
LABEL_13:
  v7 = *(_BYTE *)(a2 + 137);
  v8 = (*(_DWORD *)(a2 + 24) * *(unsigned __int8 *)(a2 + 139)) >> 6;
  *(_DWORD *)(a2 + 24) = v8;
  if ( v7 < 0 )
  {
    if ( (__int16)(*(_WORD *)(a2 + 16) - *(_WORD *)(a2 + 24)) < 0 )
      *(_DWORD *)(a2 + 24) = *(_DWORD *)(a2 + 16);
    v10 = -*(_DWORD *)(a2 + 24);
  }
  else
  {
    v9 = *(_DWORD *)(a2 + 16);
    if ( v9 + v8 <= 64 )
      goto LABEL_20;
    v10 = 64 - v9;
  }
  *(_DWORD *)(a2 + 24) = v10;
LABEL_20:
  result = v7 + *(_BYTE *)(a2 + 138);
  *(_BYTE *)(a2 + 137) = result;
  if ( result > 31 )
  {
    result -= 64;
    *(_BYTE *)(a2 + 137) = result;
  }
  *(_BYTE *)(a2 + 2) |= 2u;
  return result;
}
// 406094: using guessed type double dbl_406094;
// 40609C: using guessed type double dbl_40609C;

//----- (004027B5) --------------------------------------------------------
char __cdecl sub_4027B5(
        int a1,
        int *a2,
        _DWORD *a3,
        char a4,
        int a5,
        int a6,
        unsigned __int8 a7,
        unsigned __int8 a8,
        unsigned __int8 a9,
        int *a10,
        int *a11,
        _BYTE *a12,
        int *a13,
        char a14)
{
  int v14; // eax
  _DWORD *v15; // esi
  int v16; // ebx
  int v17; // esi
  char result; // al
  int v19; // ecx
  int v20; // [esp+2Ch] [ebp+20h]
  int v21; // [esp+30h] [ebp+24h]

  v14 = *a2;
  if ( *a2 >= a5 )
  {
    v19 = a1;
LABEL_19:
    v15 = a3;
    goto LABEL_20;
  }
  v15 = a3;
  if ( *a3 != *(unsigned __int16 *)(a6 + 4 * v14) )
  {
    *a11 += *a13;
    v19 = a1;
LABEL_20:
    *a10 = *a11 >> 16;
    ++*v15;
    goto LABEL_21;
  }
  if ( (a4 & 4) != 0 && v14 == a7 )
  {
    *a2 = a8;
    *a3 = *(unsigned __int16 *)(a6 + 4 * a8);
  }
  v21 = *(unsigned __int16 *)(a6 + 4 * *a2);
  v16 = *(unsigned __int16 *)(a6 + 4 * *a2 + 2);
  v20 = *(unsigned __int16 *)(a6 + 4 * *a2 + 4);
  v17 = v16 << 16;
  if ( *a2 == a5 - 1 )
  {
    *a10 = v16;
    *a12 = 1;
    result = a1;
    *(_BYTE *)(a1 + 2) |= a14;
    return result;
  }
  if ( (a4 & 2) == 0 || *a2 != a9 )
  {
    v19 = a1;
    goto LABEL_13;
  }
  v19 = a1;
  if ( *(_BYTE *)(a1 + 101) )
  {
LABEL_13:
    if ( v20 == v21 )
      *a13 = 0;
    else
      *a13 = ((*(unsigned __int16 *)(a6 + 4 * *a2 + 6) << 16) - v17) / (v20 - v21);
    *a11 = v17;
    ++*a2;
    goto LABEL_19;
  }
  *a10 = v16;
LABEL_21:
  result = a14;
  *(_BYTE *)(v19 + 2) |= a14;
  return result;
}

//----- (004028AE) --------------------------------------------------------
int __cdecl sub_4028AE(int a1, unsigned __int8 a2)
{
  int result; // eax
  int v3; // ecx
  bool v4; // sf
  int v5; // ecx
  int v6; // ecx

  if ( a2 < 0x10u || a2 > 0x50u )
  {
    result = a2;
    switch ( a2 >> 4 )
    {
      case 6:
      case 8:
        v3 = a1;
        result = a2 & 0xF;
        v4 = *(_DWORD *)(a1 + 16) - result < 0;
        *(_DWORD *)(a1 + 16) -= result;
        if ( v4 )
          *(_DWORD *)(a1 + 16) = 0;
        goto LABEL_9;
      case 7:
      case 9:
        v3 = a1;
        *(_DWORD *)(a1 + 16) += a2 & 0xF;
        result = 64;
        if ( *(int *)(a1 + 16) > 64 )
          *(_DWORD *)(a1 + 16) = 64;
LABEL_9:
        *(_BYTE *)(v3 + 2) |= 2u;
        return result;
      case 0xA:
        result = a1;
        *(_BYTE *)(a1 + 134) = a2 & 0xF;
        return result;
      case 0xB:
        result = a1;
        *(_BYTE *)(a1 + 135) = a2 & 0xF;
        return result;
      case 0xC:
        v5 = a1;
        result = 16 * (a2 & 0xF);
        *(_DWORD *)(a1 + 20) = result;
        goto LABEL_15;
      case 0xD:
        v5 = a1;
        result = a2 & 0xF;
        *(_DWORD *)(a1 + 20) -= result;
        goto LABEL_15;
      case 0xE:
        v5 = a1;
        result = a2 & 0xF;
        *(_DWORD *)(a1 + 20) += result;
LABEL_15:
        *(_BYTE *)(v5 + 2) |= 4u;
        break;
      case 0xF:
        result = a1;
        if ( (a2 & 0xF) != 0 )
          *(_BYTE *)(a1 + 132) = 16 * a2;
        v6 = *(_DWORD *)(a1 + 104);
        *(_BYTE *)(a1 + 2) &= ~8u;
        *(_DWORD *)(a1 + 128) = v6;
        break;
      default:
        return result;
    }
  }
  else
  {
    result = a1;
    *(_BYTE *)(a1 + 2) |= 2u;
    *(_DWORD *)(a1 + 16) = a2 - 16;
  }
  return result;
}

//----- (004029A4) --------------------------------------------------------
int __cdecl sub_4029A4(int a1, int a2)
{
  long double v2; // st7
  int v3; // edi
  long double v4; // st7
  int v5; // eax
  long double v6; // st7

  v2 = sub_4016DB(dbl_4060BC, (double)(132 - a1) * flt_4060C4);
  v3 = sub_4016D2(v2 * dbl_4060B4);
  if ( a2 < 0 && a1 )
  {
    v4 = sub_4016DB(dbl_4060BC, (double)(133 - a1) * flt_4060C4);
    v5 = (v3 - sub_4016D2(v4 * dbl_4060B4)) * -a2;
  }
  else
  {
    v6 = sub_4016DB(dbl_4060BC, (double)(131 - a1) * flt_4060C4);
    v5 = a2 * (v3 - sub_4016D2(v6 * dbl_4060B4));
  }
  return v5 / -128 + v3;
}
// 402A2A: conditional instruction was optimized away because %arg_4.4<0
// 4060B4: using guessed type double dbl_4060B4;
// 4060BC: using guessed type double dbl_4060BC;
// 4060C4: using guessed type float flt_4060C4;

//----- (00402A84) --------------------------------------------------------
int __cdecl sub_402A84(int a1)
{
  int result; // eax
  unsigned __int8 v2; // cl
  unsigned __int8 v3; // dl
  int v4; // esi
  unsigned __int8 v5; // cl

  result = a1;
  v2 = *(_BYTE *)(a1 + 146);
  v3 = *(_BYTE *)(a1 + 147);
  if ( v2 >= v3 )
    *(_DWORD *)(a1 + 24) = -*(_DWORD *)(a1 + 16);
  v4 = *(unsigned __int8 *)(a1 + 148);
  v5 = v2 + 1;
  *(_BYTE *)(a1 + 146) = v5;
  if ( v5 >= v3 + v4 )
    *(_BYTE *)(a1 + 146) = 0;
  *(_BYTE *)(a1 + 2) |= 2u;
  return result;
}

//----- (00402AC9) --------------------------------------------------------
int __cdecl sub_402AC9(int a1, int a2, int a3)
{
  int v3; // edi
  int *v4; // esi
  int result; // eax
  int *v6; // ebx
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // eax
  long double v14; // st7
  int v15; // eax
  int v16; // ebx
  unsigned __int64 v17; // rax
  int v18; // [esp+Ch] [ebp-14h]
  int *v19; // [esp+1Ch] [ebp-4h]
  int v20; // [esp+28h] [ebp+8h]
  int v21; // [esp+28h] [ebp+8h]
  unsigned int v22; // [esp+30h] [ebp+10h]

  v3 = a1;
  v4 = *(int **)(a1 + 4);
  v19 = v4;
  if ( v4 )
    a1 = *v4;
  result = *(_DWORD *)(v3 + 28) + *(_DWORD *)(v3 + 12);
  if ( !result )
    *(_BYTE *)(v3 + 2) &= ~1u;
  if ( (*(_BYTE *)(v3 + 2) & 8) != 0 )
  {
    v4 = (int *)((char *)&unk_407AB8 + 88 * a1);
    v19 = v4;
    if ( v4[7] )
    {
      if ( a1 >= 32 )
        v20 = a1 - 32;
      else
        v20 = a1 + 32;
      v6 = (int *)((char *)&unk_407AB8 + 88 * v20);
      sub_4016B4(v6, v4, 0x58u);
      *v6 = v20;
      v4[4] = 0;
      v4[1] = 0;
      v4[8] = 0;
      v4[9] = 0;
      v4 = v6;
      v19 = v6;
      *(_DWORD *)(v3 + 4) = v6;
    }
    result = (int)(v4 + 6);
    v4[7] = a2;
    if ( v4[6] >= (unsigned int)(*(_DWORD *)(a2 + 8) + *(_DWORD *)(a2 + 12)) )
      *(_DWORD *)result = 0;
    v7 = *(_DWORD *)result;
    v4[11] = 0;
    v4[10] = v7;
    v4[14] = 1;
    *(_DWORD *)result = 0;
    v4[17] = 0;
    v4[18] = 0;
    v4[21] = 0;
  }
  if ( (*(_BYTE *)(v3 + 2) & 2) != 0 )
  {
    result = sub_4016D2(
               (double)(*(_DWORD *)(v3 + 16) + *(_DWORD *)(v3 + 24))
             * (double)*(int *)(v3 + 52)
             * (double)*(int *)(v3 + 88)
             * (double)*(int *)(a3 + 300)
             * flt_4060DC);
    v8 = result;
    v21 = result;
    if ( v4 )
    {
      v9 = v4[5];
      v4[4] = v8;
      v4[1] = v8;
      v4[8] = v8 * v9 / 255;
      result = v21 * (255 - v4[5]) / 255;
      v4[9] = result;
    }
  }
  if ( (*(_BYTE *)(v3 + 2) & 4) != 0 )
  {
    v10 = *(_DWORD *)(v3 + 20) - 128;
    if ( v10 < 0 )
      v10 = 128 - *(_DWORD *)(v3 + 20);
    v11 = (128 - v10) / 32;
    result = *(_DWORD *)(v3 + 76) - 32;
    v12 = *(_DWORD *)(v3 + 20) + result * v11;
    if ( v12 < 0 )
      v12 = 0;
    if ( v12 > 255 )
      v12 = 255;
    if ( v4 )
    {
      v13 = v12 * v4[4] / 255;
      v4[5] = v12;
      v4[3] = v12;
      v4[8] = v13;
      result = v4[4] * (255 - v12) / 255;
      v4[9] = result;
    }
  }
  if ( (*(_BYTE *)(v3 + 2) & 1) != 0 )
  {
    if ( (*(_BYTE *)(a3 + 34) & 1) != 0 )
    {
      v14 = sub_4016DB(dbl_4060BC, (flt_4060D8 - (double)*(int *)(v3 + 12) + (double)*(int *)(v3 + 28)) * flt_4060D4);
      v15 = sub_4016D2(v14 * dbl_4060CC);
    }
    else
    {
      v15 = 14317056 / (*(_DWORD *)(v3 + 28) + *(_DWORD *)(v3 + 12));
    }
    v22 = v15;
    v4[2] = v15;
    if ( v15 < 100 )
      v22 = 100;
    v18 = v15;
    v16 = dword_40D304;
    LODWORD(v17) = v22 / dword_40D304;
    HIDWORD(v17) = v22 % dword_40D304;
    v19[13] = v22 / dword_40D304;
    v19[12] = v17 / (unsigned int)v16;
    result = v18;
  }
  if ( (*(_BYTE *)(v3 + 2) & 0x20) != 0 )
  {
    result = 0;
    v4[11] = 0;
    v4[10] = 0;
    v4[6] = 0;
  }
  return result;
}
// 4060BC: using guessed type double dbl_4060BC;
// 4060CC: using guessed type double dbl_4060CC;
// 4060D4: using guessed type float flt_4060D4;
// 4060D8: using guessed type float flt_4060D8;
// 4060DC: using guessed type float flt_4060DC;
// 40D304: using guessed type int dword_40D304;

//----- (00402CE2) --------------------------------------------------------
int __cdecl sub_402CE2(int a1, int a2)
{
  int result; // eax
  char v3; // dl

  result = a1;
  *(_DWORD *)(a1 + 16) = *(unsigned __int8 *)(a2 + 16);
  v3 = *(_BYTE *)(a1 + 162);
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 24);
  *(_DWORD *)(a1 + 52) = 64;
  *(_DWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 76) = 32;
  *(_DWORD *)(a1 + 68) = 0;
  *(_DWORD *)(a1 + 64) = 0;
  *(_DWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 101) = 0;
  *(_DWORD *)(a1 + 88) = 0x10000;
  *(_BYTE *)(a1 + 60) = 0;
  *(_BYTE *)(a1 + 84) = 0;
  *(_DWORD *)(a1 + 96) = 0;
  *(_DWORD *)(a1 + 92) = 0;
  if ( (v3 & 0xFu) < 4 )
    *(_BYTE *)(a1 + 133) = 0;
  if ( (v3 & 0xF0u) < 0x40 )
    *(_BYTE *)(a1 + 137) = 0;
  *(_BYTE *)(a1 + 2) |= 6u;
  *(_BYTE *)(a1 + 146) = 0;
  return result;
}

//----- (00402D63) --------------------------------------------------------
int __cdecl sub_402D63(int a1)
{
  int v1; // ebx
  int v2; // edx
  int v3; // eax
  int v4; // ecx
  int result; // eax
  bool v6; // zf
  _BYTE *v7; // ecx
  unsigned __int8 v8; // dl
  unsigned __int8 v9; // al
  char v10; // dl
  unsigned __int8 *v11; // esi
  char v12; // dl
  char v13; // dl
  unsigned __int8 v14; // dl
  unsigned __int8 *v15; // edi
  unsigned __int8 v16; // dl
  char v17; // dl
  unsigned __int8 v18; // cl
  int v19; // eax
  unsigned __int8 v20; // dl
  int v21; // edx
  bool v22; // sf
  unsigned int v23; // edx
  unsigned __int8 v24; // cl
  unsigned __int8 v25; // cl
  unsigned __int8 v26; // cl
  unsigned __int8 v27; // cl
  unsigned __int8 v28; // cl
  int v29; // eax
  unsigned __int8 v30; // cl
  unsigned int v31; // eax
  unsigned __int8 v32; // cl
  int v33; // eax
  int v34; // eax
  int v35; // eax
  int v36; // eax
  int v37; // eax
  int v38; // edx
  _DWORD *v39; // ecx
  int v40; // eax
  unsigned __int8 v41; // cl
  int v42; // ecx
  char v43; // cl
  unsigned __int16 v44; // cx
  int v45; // eax
  int v46; // ecx
  int v47; // ebx
  int v48; // ecx
  int v49; // eax
  int v50; // ecx
  unsigned int v51; // edx
  unsigned int v52; // edx
  unsigned int v53; // edx
  unsigned __int8 v54; // cl
  int v55; // [esp+8h] [ebp-28h]
  int v56; // [esp+8h] [ebp-28h]
  int v57; // [esp+Ch] [ebp-24h]
  int v58; // [esp+Ch] [ebp-24h]
  int v59; // [esp+18h] [ebp-18h]
  unsigned __int16 *v60; // [esp+18h] [ebp-18h]
  int v61; // [esp+1Ch] [ebp-14h]
  _BYTE *v62; // [esp+20h] [ebp-10h]
  int *v63; // [esp+24h] [ebp-Ch]
  char v64; // [esp+2Ch] [ebp-4h]
  bool v65; // [esp+2Dh] [ebp-3h]
  unsigned __int8 v66; // [esp+2Eh] [ebp-2h]
  unsigned __int8 v67; // [esp+2Fh] [ebp-1h]

  v1 = a1;
  v64 = 0;
  v2 = *(__int16 *)(a1 + 20);
  v3 = *(_DWORD *)(a1 + 324);
  *(_DWORD *)(a1 + 336) = -1;
  *(_DWORD *)(a1 + 332) = -1;
  v4 = *(_DWORD *)(*(_DWORD *)v1 + 8 * *(unsigned __int8 *)(v1 + v3 + 40) + 4);
  result = 5 * *(_DWORD *)(a1 + 320) * v2;
  v6 = result + v4 == 0;
  v7 = (_BYTE *)(result + v4);
  v62 = v7;
  if ( !v6 )
  {
    v61 = 0;
    if ( v2 > 0 )
    {
      while ( 1 )
      {
        v8 = v7[4];
        v9 = v8 & 0xF;
        v67 = v8 >> 4;
        v10 = v7[3];
        v11 = (unsigned __int8 *)&unk_406398 + 172 * v61;
        v66 = v9;
        v65 = v10 == 3 || v10 == 5;
        v12 = v7[1];
        if ( v12 && !v65 )
          v11[102] = v12 - 1;
        v13 = *v7;
        if ( *v7 && v13 != -1 && !v65 )
          *v11 = v13 - 1;
        v14 = v11[102];
        if ( v14 < *(__int16 *)(v1 + 32) )
        {
          v15 = (unsigned __int8 *)(*(_DWORD *)(v1 + 4) + 340 * v14);
          v16 = v15[*v11 + 68];
          if ( v16 < 0x10u )
            v63 = *(int **)&v15[4 * v16 + 4];
          else
            v63 = &dword_407A78;
          if ( !v65 )
            *((_DWORD *)v11 + 2) = v63;
        }
        else
        {
          dword_407A78 = 0;
          v15 = (unsigned __int8 *)&unk_407918;
          v63 = &dword_407A78;
        }
        v59 = *((_DWORD *)v11 + 4);
        v57 = *((_DWORD *)v11 + 3);
        v55 = *((_DWORD *)v11 + 5);
        if ( v11[108] == 7 && v7[3] != 7 )
          *((_DWORD *)v11 + 4) = v59 + *((_DWORD *)v11 + 6);
        v11[108] = v7[3];
        *((_DWORD *)v11 + 6) = 0;
        v11[2] = 0;
        v17 = *v7;
        if ( *v7 && v17 != -1 )
        {
          v18 = v17 + *((_BYTE *)v63 + 31) - 1;
          v11[103] = v18;
          v19 = *((char *)v63 + 17);
          if ( (*(_BYTE *)(v1 + 34) & 1) != 0 )
            *((_DWORD *)v11 + 26) = -64 * v18 - v19 / 2 + 7680;
          else
            *((_DWORD *)v11 + 26) = sub_4029A4(v18, v19);
          if ( !v65 )
            *((_DWORD *)v11 + 3) = *((_DWORD *)v11 + 26);
          v9 = v66;
          v7 = v62;
          v11[2] = 8;
        }
        *((_DWORD *)v11 + 7) = 0;
        v11[2] |= 3u;
        if ( v7[1] )
        {
          sub_402CE2((int)v11, (int)v63);
          v9 = v66;
          v7 = v62;
        }
        v20 = v7[2];
        if ( v20 )
        {
          sub_4028AE((int)v11, v20);
          v9 = v66;
          v7 = v62;
        }
        if ( *v7 == 0xFF || v7[3] == 20 )
          v11[101] = 1;
        if ( (v15[332] & 1) != 0 )
        {
          if ( !v11[60] )
          {
            sub_4027B5(
              (int)v11,
              (int *)v11 + 11,
              (_DWORD *)v11 + 10,
              v15[332],
              v15[324],
              (int)(v15 + 164),
              v15[328],
              v15[327],
              v15[326],
              (int *)v11 + 13,
              (int *)v11 + 12,
              v11 + 60,
              (int *)v11 + 14,
              2);
            v9 = v66;
            v7 = v62;
          }
        }
        else if ( v11[101] )
        {
          *((_DWORD *)v11 + 13) = 0;
        }
        if ( (v15[333] & 1) != 0 && !v11[84] )
        {
          sub_4027B5(
            (int)v11,
            (int *)v11 + 17,
            (_DWORD *)v11 + 16,
            v15[333],
            v15[325],
            (int)(v15 + 244),
            v15[331],
            v15[330],
            v15[329],
            (int *)v11 + 19,
            (int *)v11 + 18,
            v11 + 84,
            (int *)v11 + 20,
            4);
          v9 = v66;
          v7 = v62;
        }
        if ( v11[101] )
        {
          v21 = *((unsigned __int16 *)v15 + 169);
          v22 = *((_DWORD *)v11 + 22) - v21 < 0;
          *((_DWORD *)v11 + 22) -= v21;
          if ( v22 )
            *((_DWORD *)v11 + 22) = 0;
          v11[2] |= 2u;
        }
        v23 = (unsigned __int8)v7[3];
        if ( v23 > 0x15 )
        {
          v51 = v23 - 25;
          if ( v51 )
          {
            v52 = v51 - 2;
            if ( v52 )
            {
              v53 = v52 - 2;
              if ( v53 )
              {
                if ( v53 == 4 )
                {
                  if ( v67 == 1 )
                  {
                    if ( v9 )
                      v11[123] = v9;
                    v36 = v11[123];
LABEL_153:
                    *((_DWORD *)v11 + 3) -= v36;
                  }
                  else if ( v67 == 2 )
                  {
                    if ( v9 )
                      v11[122] = v9;
                    v37 = v11[122];
LABEL_103:
                    *((_DWORD *)v11 + 3) += v37;
                  }
                }
              }
              else
              {
                if ( v7[4] )
                {
                  v11[147] = v67 + 1;
                  v11[148] = v9 + 1;
                }
                sub_402A84((int)v11);
              }
            }
            else if ( v7[4] )
            {
              v11[127] = v9;
              v11[126] = v67;
            }
          }
          else
          {
            v54 = v7[4];
            if ( v54 )
            {
              v11[125] = v54;
LABEL_165:
              v11[2] |= 4u;
            }
          }
        }
        else if ( v23 == 21 )
        {
          if ( (v15[332] & 1) != 0 )
          {
            v44 = (unsigned __int8)v7[4];
            v45 = 0;
            if ( v44 > *((_WORD *)v15 + 84) )
            {
              v60 = (unsigned __int16 *)(v15 + 168);
              do
              {
                if ( v45 >= v15[324] )
                  break;
                v60 += 2;
                ++v45;
              }
              while ( v44 > *v60 );
            }
            *((_DWORD *)v11 + 11) = v45;
            v46 = v15[324];
            if ( v45 < v46 - 1 )
            {
              v11[60] = 0;
              v47 = v45 + 1;
              *((_DWORD *)v11 + 10) = (unsigned __int8)v62[4];
              v48 = *(unsigned __int16 *)&v15[4 * v45 + 166] << 16;
              v58 = *(unsigned __int16 *)&v15[4 * v45 + 164];
              v56 = *(unsigned __int16 *)&v15[4 * v45 + 168] - v58;
              if ( v56 )
                *((_DWORD *)v11 + 14) = ((*(unsigned __int16 *)&v15[4 * v47 + 166] << 16) - v48) / v56;
              else
                *((_DWORD *)v11 + 14) = 0;
              v49 = *((_DWORD *)v11 + 10);
              *((_DWORD *)v11 + 11) = v47;
              v1 = a1;
              v50 = *((_DWORD *)v11 + 14) * (v49 - v58) + v48;
              *((_DWORD *)v11 + 12) = v50;
              *((_DWORD *)v11 + 13) = v50 >> 16;
            }
            else
            {
              *((_DWORD *)v11 + 13) = *(unsigned __int16 *)&v15[4 * v46 + 162];
              v11[60] = 1;
            }
          }
        }
        else
        {
          switch ( v7[3] )
          {
            case 1:
              v24 = v7[4];
              if ( v24 )
                v11[121] = v24;
              break;
            case 2:
              v25 = v7[4];
              if ( v25 )
                v11[120] = v25;
              break;
            case 3:
              v26 = v7[4];
              if ( v26 )
                v11[132] = v26;
              *((_DWORD *)v11 + 32) = *((_DWORD *)v11 + 26);
              goto LABEL_65;
            case 4:
              if ( v67 )
                v11[134] = v67;
              if ( v9 )
                v11[135] = v9;
              goto LABEL_70;
            case 5:
              *((_DWORD *)v11 + 32) = *((_DWORD *)v11 + 26);
              v27 = v7[4];
              if ( v27 )
                v11[124] = v27;
LABEL_65:
              v11[2] &= 0xF6u;
              break;
            case 6:
              v28 = v7[4];
              if ( v28 )
                v11[124] = v28;
LABEL_70:
              sub_40255A((int)v11);
              break;
            case 7:
              if ( v67 )
                v11[138] = v67;
              if ( v9 )
                v11[139] = v9;
              break;
            case 8:
              v29 = (unsigned __int8)v7[4];
LABEL_115:
              *((_DWORD *)v11 + 5) = v29;
              goto LABEL_165;
            case 9:
              v30 = v7[4];
              if ( v30 )
                *((_DWORD *)v11 + 28) = v30;
              if ( *((_DWORD *)v11 + 1) )
              {
                v31 = *((_DWORD *)v11 + 28) << 8;
                if ( v31 < v63[2] + v63[3] )
                  *(_DWORD *)(*((_DWORD *)v11 + 1) + 24) = v31;
                else
                  v11[2] = v11[2] & 0xD7 | 0x20;
              }
              break;
            case 0xA:
              v32 = v7[4];
              if ( v32 )
                v11[124] = v32;
              break;
            case 0xB:
              v33 = (unsigned __int8)v7[4];
              *(_DWORD *)(v1 + 332) = 0;
              *(_DWORD *)(v1 + 336) = v33;
              if ( *(_DWORD *)(v1 + 336) >= *(__int16 *)(v1 + 16) )
                *(_DWORD *)(v1 + 336) = 0;
              v64 = 1;
              break;
            case 0xC:
              v34 = (unsigned __int8)v7[4];
LABEL_119:
              *((_DWORD *)v11 + 4) = v34;
              goto LABEL_120;
            case 0xD:
              v35 = v9 + 10 * v67;
              *(_DWORD *)(v1 + 332) = v35;
              if ( v35 > 63 )
                *(_DWORD *)(v1 + 332) = 0;
              if ( !v64 )
                *(_DWORD *)(v1 + 336) = *(_DWORD *)(v1 + 324) + 1;
              if ( *(_DWORD *)(v1 + 336) >= *(__int16 *)(v1 + 16) )
                *(_DWORD *)(v1 + 336) = 0;
              break;
            case 0xE:
              switch ( v67 )
              {
                case 1u:
                  if ( v9 )
                    v11[168] = v9;
                  v36 = 4 * v11[168];
                  goto LABEL_153;
                case 2u:
                  if ( v9 )
                    v11[169] = v9;
                  v37 = 4 * v11[169];
                  goto LABEL_103;
                case 4u:
                  v11[162] = v9 | v11[162] & 0xF0;
                  break;
                case 5u:
                  *((_BYTE *)v63 + 17) = v9;
                  break;
                case 6u:
                  if ( v9 )
                  {
                    v38 = *((_DWORD *)v11 + 39);
                    v39 = v11 + 156;
                    if ( v38 )
                      *v39 = v38 - 1;
                    else
                      *v39 = v9;
                    if ( *v39 )
                      *(_DWORD *)(v1 + 320) = *((_DWORD *)v11 + 38) - 1;
                  }
                  else
                  {
                    *((_DWORD *)v11 + 38) = *(_DWORD *)(v1 + 320);
                  }
                  break;
                case 7u:
                  v11[162] = v11[162] & 0xF | (16 * v9);
                  break;
                case 8u:
                  v29 = 16 * v9;
                  goto LABEL_115;
                case 0xAu:
                  if ( v9 )
                    v11[167] = v9;
                  *((_DWORD *)v11 + 4) += v11[167];
                  v34 = 64;
                  if ( *((int *)v11 + 4) > 64 )
                    goto LABEL_119;
                  goto LABEL_120;
                case 0xBu:
                  if ( v9 )
                    v11[167] = v9;
                  v40 = v11[167];
                  v22 = *((_DWORD *)v11 + 4) - v40 < 0;
                  *((_DWORD *)v11 + 4) -= v40;
                  if ( v22 )
                    *((_DWORD *)v11 + 4) = 0;
                  goto LABEL_120;
                case 0xDu:
                  *((_DWORD *)v11 + 4) = v59;
                  *((_DWORD *)v11 + 3) = v57;
                  *((_DWORD *)v11 + 5) = v55;
                  v11[2] &= 0xF0u;
                  break;
                case 0xEu:
                  *(_DWORD *)(v1 + 328) = v9 * *(_DWORD *)(v1 + 312);
                  break;
                default:
                  goto LABEL_166;
              }
              break;
            case 0xF:
              v41 = v7[4];
              if ( v41 >= 0x20u )
                sub_401AB1(v1, v41);
              else
                *(_DWORD *)(v1 + 312) = v41;
              break;
            case 0x10:
              v42 = (unsigned __int8)v7[4];
              *(_DWORD *)(v1 + 300) = v42;
              if ( v42 > 64 )
                *(_DWORD *)(v1 + 300) = 64;
LABEL_120:
              v11[2] |= 2u;
              break;
            case 0x11:
              v43 = v7[4];
              if ( v43 )
                *(_BYTE *)(v1 + 304) = v43;
              break;
            default:
              break;
          }
        }
LABEL_166:
        sub_4025E8((int)v11, v15);
        sub_402AC9((int)v11, (int)v63, v1);
        result = *(__int16 *)(v1 + 20);
        v62 += 5;
        if ( ++v61 >= result )
          break;
        v7 = v62;
      }
    }
  }
  return result;
}
// 407A78: using guessed type int dword_407A78;

//----- (00403596) --------------------------------------------------------
int __cdecl sub_403596(int a1)
{
  int v2; // ecx
  int v3; // edx
  int result; // eax
  bool v5; // zf
  int v6; // edx
  unsigned __int8 *v7; // esi
  unsigned __int8 v8; // al
  unsigned __int8 *v9; // edi
  unsigned __int8 v10; // al
  unsigned __int8 v11; // al
  unsigned __int8 v12; // bl
  char v13; // al
  unsigned __int8 v14; // bl
  char v15; // cl
  int v16; // eax
  bool v17; // sf
  unsigned __int8 v18; // cl
  unsigned int v19; // edx
  char v20; // cl
  int v21; // eax
  char v22; // cl
  unsigned __int8 v23; // cl
  unsigned __int8 v24; // al
  unsigned __int8 v25; // cl
  char v26; // cl
  int v27; // eax
  int v28; // ebx
  unsigned __int8 v29; // al
  unsigned __int8 v30; // al
  int v31; // eax
  int *v32; // eax
  unsigned __int8 v33; // cl
  unsigned __int8 v34; // al
  unsigned __int8 v35; // cl
  unsigned __int8 v36; // cl
  unsigned __int8 v37; // al
  unsigned __int8 v38; // cl
  int v39; // eax
  unsigned __int8 v40; // al
  unsigned __int8 v41; // [esp+Bh] [ebp-Dh]
  int *v42; // [esp+Ch] [ebp-Ch]
  int v43; // [esp+10h] [ebp-8h]
  int v44; // [esp+14h] [ebp-4h]
  unsigned __int8 v45; // [esp+1Ch] [ebp+4h]
  int v46; // [esp+1Ch] [ebp+4h]

  v2 = *(__int16 *)(a1 + 20);
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 8 * *(unsigned __int8 *)(a1 + *(_DWORD *)(a1 + 324) + 40) + 4);
  result = 5 * v2 * *(_DWORD *)(a1 + 320);
  v5 = result + v3 == 0;
  v6 = result + v3;
  v43 = v6;
  if ( !v5 )
  {
    v44 = 0;
    if ( v2 > 0 )
    {
      while ( 1 )
      {
        v7 = (unsigned __int8 *)&unk_406398 + 172 * v44;
        v8 = v7[102];
        if ( v8 < *(__int16 *)(a1 + 32) )
        {
          v9 = (unsigned __int8 *)(*(_DWORD *)(a1 + 4) + 340 * v8);
          v10 = v9[*v7 + 68];
          if ( v10 < 0x10u )
            v42 = *(int **)&v9[4 * v10 + 4];
          else
            v42 = &dword_407A78;
          if ( !v42 )
            v42 = &dword_407A78;
        }
        else
        {
          dword_407A78 = 0;
          v9 = (unsigned __int8 *)&unk_407918;
          v42 = &dword_407A78;
        }
        v41 = *(_BYTE *)(v6 + 3);
        v11 = *(_BYTE *)(v6 + 4);
        *((_DWORD *)v7 + 6) = 0;
        *((_DWORD *)v7 + 7) = 0;
        v7[2] = 0;
        v12 = v11;
        v45 = v11 & 0xF;
        v13 = v9[332];
        v14 = v12 >> 4;
        if ( (v13 & 1) != 0 && !v7[60] )
          sub_4027B5(
            (int)v7,
            (int *)v7 + 11,
            (_DWORD *)v7 + 10,
            v13,
            v9[324],
            (int)(v9 + 164),
            v9[328],
            v9[327],
            v9[326],
            (int *)v7 + 13,
            (int *)v7 + 12,
            v7 + 60,
            (int *)v7 + 14,
            2);
        v15 = v9[333];
        if ( (v15 & 1) != 0 && !v7[84] )
          sub_4027B5(
            (int)v7,
            (int *)v7 + 17,
            (_DWORD *)v7 + 16,
            v15,
            v9[325],
            (int)(v9 + 244),
            v9[331],
            v9[330],
            v9[329],
            (int *)v7 + 19,
            (int *)v7 + 18,
            v7 + 84,
            (int *)v7 + 20,
            4);
        if ( v7[101] )
        {
          v16 = *((unsigned __int16 *)v9 + 169);
          v17 = *((_DWORD *)v7 + 22) - v16 < 0;
          *((_DWORD *)v7 + 22) -= v16;
          if ( v17 )
            *((_DWORD *)v7 + 22) = 0;
          v7[2] |= 2u;
        }
        v18 = *(_BYTE *)(v43 + 2);
        v19 = (v18 >> 4) - 6;
        if ( v18 >> 4 == 6 )
          break;
        v19 = (v18 >> 4) - 7;
        if ( v18 >> 4 == 7 )
        {
          *((_DWORD *)v7 + 4) += v18 & 0xF;
          if ( *((int *)v7 + 4) > 64 )
            *((_DWORD *)v7 + 4) = 64;
LABEL_38:
          v7[2] |= 2u;
          goto LABEL_39;
        }
        if ( v18 >> 4 == 11 )
        {
          v7[135] = v18 & 0xF;
          sub_40255A((int)v7);
          v7[133] += v7[134];
          v20 = v7[133];
          if ( v20 > 31 )
            v7[133] = v20 - 64;
        }
        else
        {
          v19 = (v18 >> 4) - 13;
          if ( v18 >> 4 == 13 )
          {
            *((_DWORD *)v7 + 5) -= v18 & 0xF;
            goto LABEL_30;
          }
          v19 = (v18 >> 4) - 14;
          if ( v18 >> 4 == 14 )
          {
            *((_DWORD *)v7 + 5) += v18 & 0xF;
LABEL_30:
            v7[2] |= 4u;
            goto LABEL_39;
          }
          v19 = (v18 >> 4) - 15;
          if ( v18 >> 4 == 15 )
            sub_402517((int)v7);
        }
LABEL_39:
        if ( v41 > 7u )
        {
          switch ( v41 )
          {
            case 0xAu:
              goto LABEL_50;
            case 0xEu:
              switch ( v14 )
              {
                case 9u:
                  if ( v45 && !(*(_DWORD *)(a1 + 308) % (int)v45) )
                    v7[2] |= 0xBu;
                  break;
                case 0xCu:
                  if ( *(_DWORD *)(a1 + 308) != v45 )
                    goto LABEL_133;
                  goto LABEL_131;
                case 0xDu:
                  if ( *(_DWORD *)(a1 + 308) == v45 )
                  {
                    sub_402CE2((int)v7, (int)v42);
                    v39 = *((_DWORD *)v7 + 26);
                    v7[2] |= 1u;
                    *((_DWORD *)v7 + 3) = v39;
                    v40 = *(_BYTE *)(v43 + 2);
                    if ( v40 )
                      sub_4028AE((int)v7, v40);
                    goto LABEL_122;
                  }
                  v7[2] &= 0xF0u;
                  break;
                default:
                  goto LABEL_133;
              }
              break;
            case 0x11u:
              v36 = *(_BYTE *)(a1 + 304);
              v37 = v36 & 0xF;
              v38 = v36 >> 4;
              if ( v38 )
              {
                *(_DWORD *)(a1 + 300) += v38;
                if ( *(int *)(a1 + 300) > 64 )
                  *(_DWORD *)(a1 + 300) = 64;
              }
              else if ( v37 )
              {
                v17 = *(_DWORD *)(a1 + 300) - v37 < 0;
                *(_DWORD *)(a1 + 300) -= v37;
                if ( v17 )
                  *(_DWORD *)(a1 + 300) = 0;
              }
              break;
            case 0x19u:
              v33 = v7[125];
              v34 = v33 & 0xF;
              v35 = v33 >> 4;
              if ( v35 )
              {
                *((_DWORD *)v7 + 5) += v35;
                if ( *((int *)v7 + 5) > 255 )
                  *((_DWORD *)v7 + 5) = 255;
              }
              else if ( v34 )
              {
                v17 = *((_DWORD *)v7 + 5) - v34 < 0;
                *((_DWORD *)v7 + 5) -= v34;
                if ( v17 )
                  *((_DWORD *)v7 + 5) = 0;
              }
              v7[2] |= 4u;
              break;
            case 0x1Bu:
              v29 = v7[127];
              if ( v29 && !(*(_DWORD *)(a1 + 308) % (int)v29) )
              {
                v30 = v7[126];
                if ( v30 )
                {
                  switch ( v30 )
                  {
                    case 1u:
                      --*((_DWORD *)v7 + 4);
                      break;
                    case 2u:
                      *((_DWORD *)v7 + 4) -= 2;
                      break;
                    case 3u:
                      *((_DWORD *)v7 + 4) -= 4;
                      break;
                    case 4u:
                      *((_DWORD *)v7 + 4) -= 8;
                      break;
                    case 5u:
                      *((_DWORD *)v7 + 4) -= 16;
                      break;
                    case 6u:
                      v31 = 2 * *((_DWORD *)v7 + 4) / 3;
                      goto LABEL_96;
                    case 7u:
                      *((int *)v7 + 4) >>= 1;
                      break;
                    case 9u:
                      ++*((_DWORD *)v7 + 4);
                      break;
                    case 0xAu:
                      *((_DWORD *)v7 + 4) += 2;
                      break;
                    case 0xBu:
                      *((_DWORD *)v7 + 4) += 4;
                      break;
                    case 0xCu:
                      *((_DWORD *)v7 + 4) += 8;
                      break;
                    case 0xDu:
                      *((_DWORD *)v7 + 4) += 16;
                      break;
                    case 0xEu:
                      v31 = 3 * *((_DWORD *)v7 + 4) / 2;
LABEL_96:
                      *((_DWORD *)v7 + 4) = v31;
                      break;
                    case 0xFu:
                      *((_DWORD *)v7 + 4) *= 2;
                      break;
                    default:
                      break;
                  }
                  v32 = (int *)(v7 + 16);
                  if ( *((int *)v7 + 4) > 64 )
                    *v32 = 64;
                  if ( *v32 < 0 )
                    *v32 = 0;
                  v7[2] |= 2u;
                }
LABEL_122:
                v7[2] |= 8u;
              }
              break;
            case 0x1Du:
              sub_402A84((int)v7);
              break;
          }
        }
        else
        {
          if ( v41 == 7 )
          {
            sub_4026D3(v19, (int)v7);
            goto LABEL_133;
          }
          if ( v41 )
          {
            switch ( v41 )
            {
              case 1u:
                *((_DWORD *)v7 + 3) -= 4 * v7[121];
                *((_DWORD *)v7 + 7) = 0;
                if ( *((int *)v7 + 3) < 56 )
                  *((_DWORD *)v7 + 3) = 56;
                goto LABEL_58;
              case 2u:
                *((_DWORD *)v7 + 3) += 4 * v7[120];
                *((_DWORD *)v7 + 7) = 0;
                goto LABEL_58;
              case 3u:
                *((_DWORD *)v7 + 7) = 0;
                sub_402517((int)v7);
                goto LABEL_133;
            }
            if ( v41 != 4 )
            {
              if ( v41 == 5 )
              {
                *((_DWORD *)v7 + 7) = 0;
                sub_402517((int)v7);
              }
              else
              {
                if ( v41 != 6 )
                  goto LABEL_133;
                sub_40255A((int)v7);
                v7[133] += v7[134];
                v22 = v7[133];
                if ( v22 > 31 )
                  v7[133] = v22 - 64;
              }
LABEL_50:
              v23 = v7[124];
              v24 = v23 & 0xF;
              v25 = v23 >> 4;
              if ( v25 )
              {
                *((_DWORD *)v7 + 4) += v25;
                if ( *((int *)v7 + 4) > 64 )
                  *((_DWORD *)v7 + 4) = 64;
                goto LABEL_132;
              }
              if ( !v24 )
                goto LABEL_132;
              v17 = *((_DWORD *)v7 + 4) - v24 < 0;
              *((_DWORD *)v7 + 4) -= v24;
              if ( !v17 )
                goto LABEL_132;
LABEL_131:
              *((_DWORD *)v7 + 4) = 0;
LABEL_132:
              v7[2] |= 2u;
              goto LABEL_133;
            }
            sub_40255A((int)v7);
            v7[133] += v7[134];
            v26 = v7[133];
            if ( v26 > 31 )
              v7[133] = v26 - 64;
          }
          else if ( *(_BYTE *)(v43 + 4) )
          {
            if ( *(_DWORD *)(a1 + 308) % 3 == 1 )
            {
              if ( (*(_BYTE *)(a1 + 34) & 1) != 0 )
              {
                v27 = v14;
LABEL_66:
                *((_DWORD *)v7 + 7) = v27 << 6;
              }
              else
              {
                v28 = sub_4029A4(v14 + v7[103], *((char *)v42 + 17));
                *((_DWORD *)v7 + 7) = v28 - sub_4029A4(v7[103], *((char *)v42 + 17));
              }
            }
            else if ( *(_DWORD *)(a1 + 308) % 3 == 2 )
            {
              if ( (*(_BYTE *)(a1 + 34) & 1) != 0 )
              {
                v27 = v45;
                goto LABEL_66;
              }
              v46 = sub_4029A4(v45 + v7[103], *((char *)v42 + 17));
              *((_DWORD *)v7 + 7) = v46 - sub_4029A4(v7[103], *((char *)v42 + 17));
            }
LABEL_58:
            v7[2] |= 1u;
          }
        }
LABEL_133:
        sub_4025E8((int)v7, v9);
        sub_402AC9((int)v7, (int)v42, a1);
        result = *(__int16 *)(a1 + 20);
        v43 += 5;
        if ( ++v44 >= result )
          return result;
        v6 = v43;
      }
      v21 = v18 & 0xF;
      v17 = *((_DWORD *)v7 + 4) - v21 < 0;
      *((_DWORD *)v7 + 4) -= v21;
      if ( v17 )
        *((_DWORD *)v7 + 4) = 0;
      goto LABEL_38;
    }
  }
  return result;
}
// 403983: variable 'v19' is possibly undefined
// 407A78: using guessed type int dword_407A78;

//----- (00403CD6) --------------------------------------------------------
int __cdecl sub_403CD6(int *a1, int a2)
{
  int v2; // esi
  int v3; // eax
  int *v4; // ebx
  int v5; // eax
  unsigned __int8 *v6; // ecx
  int v7; // edx
  int v8; // eax
  HGLOBAL v9; // eax
  bool v10; // zf
  int v11; // eax
  _DWORD *v12; // edi
  char *v13; // eax
  int v14; // ecx
  char *v15; // ecx
  char *v16; // eax
  int v17; // eax
  _DWORD *v18; // edi
  HGLOBAL v19; // eax
  bool v20; // cc
  _DWORD *v21; // edi
  bool v22; // cf
  char *v23; // eax
  char *v24; // esi
  int v25; // eax
  int v26; // eax
  _DWORD *v27; // edi
  int v28; // esi
  int v29; // eax
  unsigned int v30; // edi
  void (__cdecl *v31)(HGLOBAL, unsigned int, _DWORD, int, unsigned int); // eax
  _WORD *v32; // edi
  int i; // eax
  __int16 v34; // cx
  int v35; // edi
  _WORD *v36; // ecx
  unsigned int j; // edx
  int v38; // eax
  char v39; // cl
  _WORD *v40; // eax
  _WORD *v41; // eax
  int v42; // eax
  int v44; // [esp-10h] [ebp-148h]
  int v45; // [esp-10h] [ebp-148h]
  int v46; // [esp-8h] [ebp-140h]
  int v47; // [esp-4h] [ebp-13Ch]
  HGLOBAL v48; // [esp-4h] [ebp-13Ch]
  _BYTE v49[256]; // [esp+Ch] [ebp-12Ch] BYREF
  char v50[4]; // [esp+10Ch] [ebp-2Ch] BYREF
  int v51; // [esp+110h] [ebp-28h] BYREF
  int v52; // [esp+114h] [ebp-24h] BYREF
  int v53; // [esp+118h] [ebp-20h]
  int v54; // [esp+11Ch] [ebp-1Ch] BYREF
  _DWORD *v55; // [esp+120h] [ebp-18h]
  unsigned int v56; // [esp+124h] [ebp-14h] BYREF
  char *v57; // [esp+128h] [ebp-10h]
  int v58; // [esp+12Ch] [ebp-Ch]
  HGLOBAL hMem; // [esp+130h] [ebp-8h]
  unsigned __int16 v60; // [esp+134h] [ebp-4h] BYREF
  char v61; // [esp+137h] [ebp-1h] BYREF

  v2 = a2;
  v54 = 0;
  sub_40173F(a2, 0, 0);
  sub_4016FC(v49, 0x11u, v2);
  v3 = 0;
  while ( v49[v3] == byte_4060E5[v3] )
  {
    if ( ++v3 >= 17 )
    {
      v4 = a1;
      a1[87] = (int)sub_403C1E;
      *((_BYTE *)v4 + 296) = 64;
      sub_40173F(v2, 60, 0);
      sub_4016FC(&v51, 4u, v2);
      sub_4016FC(v4 + 4, 6u, v2);
      sub_4016FC(&v54, 2u, v2);
      sub_4016FC(v4 + 8, 0x108u, v2);
      sub_40173F(v2, v51 + 60, 0);
      v5 = *((__int16 *)v4 + 8);
      v4[6] = 0;
      if ( v5 > 0 )
      {
        v6 = (unsigned __int8 *)(v4 + 10);
        do
        {
          v7 = *v6;
          if ( v7 >= v4[6] )
            v4[6] = v7 + 1;
          ++v6;
        }
        while ( (int)&v6[-40 - (_DWORD)v4] < v5 );
      }
      v8 = (unsigned __int16)v54;
      if ( v4[6] > (unsigned __int16)v54 )
        v8 = v4[6];
      v4[7] = v8;
      v9 = GlobalAlloc(0x40u, 8 * v8);
      v58 = 0;
      v10 = (_WORD)v54 == 0;
      *v4 = (int)v9;
      if ( !v10 )
      {
        do
        {
          v11 = *v4;
          v61 = 0;
          v12 = (_DWORD *)(v11 + 8 * v58);
          sub_4016FC(&v52, 4u, v2);
          sub_4016FC(&v61, 1u, v2);
          sub_4016FC(&v60, 2u, v2);
          *v12 = v60;
          sub_4016FC((char *)&v56 + 2, 2u, v2);
          v13 = (char *)GlobalAlloc(0x40u, 5 * *v12 * *((__int16 *)v4 + 10));
          v12[1] = v13;
          if ( HIWORD(v56) )
          {
            v14 = *v12 * *((__int16 *)v4 + 10);
            v55 = 0;
            v57 = v13;
            if ( v14 > 0 )
            {
              hMem = v13 + 1;
              do
              {
                sub_4016FC((char *)&a1 + 3, 1u, v2);
                if ( SHIBYTE(a1) >= 0 )
                {
                  if ( HIBYTE(a1) )
                    *v57 = HIBYTE(a1);
                  sub_4016FC(hMem, 4u, v2);
                }
                else
                {
                  if ( (HIBYTE(a1) & 1) != 0 )
                    sub_4016FC(v57, 1u, v2);
                  if ( (HIBYTE(a1) & 2) != 0 )
                    sub_4016FC(hMem, 1u, v2);
                  if ( (HIBYTE(a1) & 4) != 0 )
                    sub_4016FC((char *)hMem + 1, 1u, v2);
                  if ( (HIBYTE(a1) & 8) != 0 )
                    sub_4016FC((char *)hMem + 2, 1u, v2);
                  if ( (HIBYTE(a1) & 0x10) != 0 )
                    sub_4016FC((char *)hMem + 3, 1u, v2);
                }
                v15 = v57;
                if ( *v57 == 97 )
                  *v57 = -1;
                v16 = (char *)hMem;
                if ( *(_BYTE *)hMem > 0x80u )
                  *(_BYTE *)hMem = 0;
                hMem = v16 + 5;
                v55 = (_DWORD *)((char *)v55 + 1);
                v17 = *v12 * *((__int16 *)v4 + 10);
                v57 = v15 + 5;
              }
              while ( (int)v55 < v17 );
            }
          }
          ++v58;
        }
        while ( v58 < (unsigned __int16)v54 );
      }
      if ( (unsigned __int16)v54 < v4[6] )
      {
        v58 = (unsigned __int16)v54;
        do
        {
          v18 = (_DWORD *)(*v4 + 8 * v58);
          *v18 = 64;
          v19 = GlobalAlloc(0x40u, 320 * *((__int16 *)v4 + 10));
          ++v58;
          v18[1] = v19;
        }
        while ( v58 < v4[6] );
      }
      v4[1] = (int)GlobalAlloc(0x40u, 340 * *((__int16 *)v4 + 16));
      v20 = *((_WORD *)v4 + 16) <= 0;
      v58 = 0;
      if ( v20 )
        return 1;
      v53 = 0;
      while ( 1 )
      {
        v21 = (_DWORD *)(v4[1] + v53);
        hMem = v21;
        v57 = (char *)dword_406318;
        sub_4016FC(&v52, 4u, v2);
        v57 += v52;
        sub_40173F(v2, 23, 1);
        sub_4016FC(&v60, 2u, v2);
        if ( v60 > 0x10u )
          return 0;
        *v21 = v60;
        if ( v60 )
        {
          HIBYTE(a1) = 0;
          sub_4016FC(v50, 4u, v2);
          sub_4016FC(v21 + 17, 0x60u, v2);
          sub_4016FC(v21 + 41, 0x30u, v2);
          sub_4016FC(v21 + 61, 0x30u, v2);
          sub_4016FC(v21 + 81, 0x10u, v2);
          v22 = *((_BYTE *)v21 + 324) < 2u;
          *((_WORD *)v21 + 169) *= 2;
          if ( v22 )
            *((_BYTE *)v21 + 332) = 0;
          if ( *((_BYTE *)v21 + 325) < 2u )
            *((_BYTE *)v21 + 333) = 0;
          sub_40173F(v2, (int)v57, 0);
          v56 = 0;
          if ( !v60 )
            goto LABEL_68;
          v55 = v21 + 1;
          do
          {
            v23 = (char *)GlobalAlloc(0x40u, 0x30u);
            v47 = a2;
            v24 = v23;
            *v55 = v23;
            sub_4016FC(v23 + 4, 0xEu, v47);
            v44 = a2;
            v24[29] = 1;
            v24[28] = 8;
            sub_4016FC(&v61, 1u, v44);
            if ( (v61 & 1) != 0 )
              v24[29] = v24[29] & 0xFC | 2;
            if ( (v61 & 2) != 0 )
              v24[29] = v24[29] & 0xF8 | 4;
            if ( (v61 & 0x10) != 0 )
              v24[28] = 16;
            if ( (v24[29] & 1) != 0 )
            {
              v25 = *((_DWORD *)v24 + 1);
              *((_DWORD *)v24 + 2) = 0;
              *((_DWORD *)v24 + 3) = v25;
            }
            if ( v24[28] == 16 )
            {
              *((_DWORD *)v24 + 1) >>= 1;
              *((_DWORD *)v24 + 2) >>= 1;
              *((_DWORD *)v24 + 3) >>= 1;
            }
            if ( !*((_DWORD *)v24 + 3) )
            {
              v26 = *((_DWORD *)v24 + 1);
              *((_DWORD *)v24 + 2) = 0;
              *((_DWORD *)v24 + 3) = v26;
              v24[29] = 1;
            }
            sub_4016FC((char *)&a1 + 3, 1u, a2);
            v45 = a2;
            *((_DWORD *)v24 + 6) = HIBYTE(a1);
            sub_4016FC((char *)&a1 + 3, 1u, v45);
            v24[31] = HIBYTE(a1);
            sub_40173F(a2, 23, 1);
            v57 = (char *)(2 * *((_DWORD *)v24 + 1));
            if ( *(_DWORD *)v24 )
              GlobalFree(*(HGLOBAL *)v24);
            if ( v57 )
              *(_DWORD *)v24 = GlobalAlloc(0x40u, (SIZE_T)(v57 + 16));
            else
              *(_DWORD *)v24 = 0;
            ++v56;
            ++v55;
          }
          while ( v56 < v60 );
          if ( v56 < 0x10 )
          {
LABEL_68:
            memset32((char *)hMem + 4 * v56 + 4, (int)&dword_407A78, 16 - v56);
            v21 = hMem;
          }
          v56 = 0;
          if ( v60 )
          {
            v27 = v21 + 1;
            v55 = v27;
            do
            {
              v28 = *v27;
              v29 = *(_DWORD *)(*v27 + 4);
              v30 = (v29 * (unsigned int)*(unsigned __int8 *)(*v27 + 28)) >> 3;
              if ( v29 )
              {
                hMem = GlobalAlloc(0x40u, 2 * v29 + 16);
                v31 = (void (__cdecl *)(HGLOBAL, unsigned int, _DWORD, int, unsigned int))v4[88];
                if ( v31 )
                {
                  v31(hMem, v30, *(unsigned __int8 *)(v28 + 28), v58, v56);
                  sub_40173F(a2, v30, 1);
                }
                else
                {
                  sub_4016FC(hMem, v30, a2);
                }
                if ( *(_BYTE *)(v28 + 28) == 8 )
                {
                  v32 = *(_WORD **)v28;
                  for ( i = 0; i < *(_DWORD *)(v28 + 4); ++i )
                  {
                    LOBYTE(v34) = 0;
                    HIBYTE(v34) = *((_BYTE *)hMem + i);
                    *v32++ = v34;
                  }
                  v48 = hMem;
                  *(_BYTE *)(v28 + 28) = 16;
                  GlobalFree(v48);
                }
                else
                {
                  GlobalFree(*(HGLOBAL *)v28);
                  *(_DWORD *)v28 = hMem;
                }
                v35 = 0;
                if ( !v4[88] )
                {
                  v36 = *(_WORD **)v28;
                  for ( j = 0; j < *(_DWORD *)(v28 + 4); v35 = v38 )
                  {
                    v38 = v35 + (unsigned __int16)*v36;
                    *v36++ = v38;
                    ++j;
                  }
                }
                v39 = *(_BYTE *)(v28 + 29);
                v40 = *(_WORD **)v28;
                if ( v39 == 4 )
                {
                  v41 = &v40[*(_DWORD *)(v28 + 8) + *(_DWORD *)(v28 + 12)];
                  *v41 = *(v41 - 1);
                }
                else if ( v39 == 2 )
                {
                  v40[*(_DWORD *)(v28 + 8) + *(_DWORD *)(v28 + 12)] = v40[*(_DWORD *)(v28 + 8)];
                }
              }
              ++v56;
              v27 = ++v55;
            }
            while ( v56 < v60 );
          }
        }
        else
        {
          v46 = (int)v57;
          memset32((char *)hMem + 4, (int)&dword_407A78, 0x10u);
          sub_40173F(a2, v46, 0);
        }
        v42 = *((__int16 *)v4 + 16);
        ++v58;
        v53 += 340;
        if ( v58 >= v42 )
          return 1;
        v2 = a2;
      }
    }
  }
  return 0;
}
// 403C1E: using guessed type int sub_403C1E();
// 406318: using guessed type int dword_406318;
// 407A78: using guessed type int dword_407A78;

// nfuncs=65 queued=33 decompiled=33 lumina nreq=0 worse=0 better=0
#error "There were 1 decompilation failure(s) on 33 function(s)"
